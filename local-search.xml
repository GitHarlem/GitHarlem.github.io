<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[编程笔记]-Dynamic_Programming(General)动态规划总概</title>
    <link href="/2024/08/07/Dynamic-Programming-General/"/>
    <url>/2024/08/07/Dynamic-Programming-General/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客只用来概述思路，并没有对具体问题的描述。</p><p>具体问题的解题描述，请移步左侧目录。</p><p>（四押(^▽^)）</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>动态规划嘛，大概就两个步骤：<br>状态表示和状态计算</p><h2 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h2><p>首先呢，思考一下整个问题需要用几维的状态表示，每个状态含义是什么。</p><p>一般情况下，我们要考虑一个状态的<strong>集合</strong>和<strong>属性</strong>。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>首先，我们要明白这个集合的所有选法是啥。</p><p>通常情况下，要满足以下条件：</p><ul><li>从一定范围（通常是前i个）里面选</li><li>选出来之后满足限制</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>通常情况下，一个状态，都表示的是一个集合中的<strong>Max&#x2F;Min&#x2F;Num&#x2F;Sum…</strong></p><h2 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h2><p>如何一步一步计算出每一个状态。</p><h2 id="DP优化"><a href="#DP优化" class="headerlink" title="DP优化"></a>DP优化</h2><p>一般来说就是对代码或者计算方程做一个等价变形。</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Knapsack_Problem(Basic)背包问题（基础版）</title>
    <link href="/2024/08/07/Knapsack-Problem-Basic/"/>
    <url>/2024/08/07/Knapsack-Problem-Basic/</url>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>背包问题，就是给定你一些背包和一些物品，通常情况下给出物品的价值和体积，再在不同类型中给定不同的限制条件，最后往往希望你给出能获得的最大价值。</p><h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>限制背包的最大体积，给出每种物品的体积和价值，每种物品<strong>只有一个</strong>，求能获得的最大价值。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h3><p>考虑状态dp[i][j]，表示在前i件物品中有j的体积可以获得的最大利润。</p><p>对于每个dp[i][j]，有两种情况：选不选第j件物品。</p><ul><li>若选，则dp[i][j]&#x3D;dp[i-1][j-v[i]]+w[i]，表示在前i-1个物品中，若有j-当前物品体积的剩余体积，还能获得的最大价值，加上当前物品的价值。</li><li>若不选，则dp[i][j]&#x3D;dp[i-1][j]，表示就不说了。</li><li>两者取最大值，作为在前i个物品中有j的体积的最大价值。</li></ul><p>还是挺好理解的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span><span class="hljs-number">+3</span>;<br><br><span class="hljs-type">int</span> n,nv;<br><span class="hljs-type">int</span> v[N],w[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-comment">//f[0][i]全为0，但初始默认就是0，就不用初始化了。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>            f[i][j]=f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">if</span>(j&gt;=v[i])f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j-v[i]]+w[i],f[i][j]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[n][m]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h3><p>毕竟是二维背包，还是有点好空间，这里就思考把它转化成一维：</p><p>首先，可以省略的肯定是第一维。这里如下推导：</p><p>对于对于当前循环而言，dp中储存的其实就是i-1的值，所以第一个维度没有必要，考虑使用滚动数组实现优化。</p><p>特殊地，我们应该从后往前循环，因为新的dp中会用到它前面的值，我们必须保证它前面的值是前i-1个的dp值。若从前往后循环，它前面的值就是更新之后的值了。</p><p>另外，w[i]之前的体积，我们可以不操作，它们就默认还是i-1的值，仍然符合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span><span class="hljs-number">+3</span>;<br><br><span class="hljs-type">int</span> n,nv;<br><span class="hljs-type">int</span> v[N],w[N];<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>            f[j]=<span class="hljs-built_in">max</span>(f[j-v[i]]+w[i],f[j]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[m]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是很简单~</p><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h2><p>限制背包的最大体积，给出每种物品的体积和价值，每种物品<strong>有无限个</strong>，求能获得的最大价值。</p><h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>完全背包和01背包很像的，所以就接着01背包讲了。</p><h3 id="基础版-1"><a href="#基础版-1" class="headerlink" title="基础版"></a>基础版</h3><p>这里与01背包唯一的区别就是每种物品可以放多个，并且没有数量限制。怎么解决呢？事实上，我们只需要更改一下状态转移方程就行了<del>（废话）</del></p><p>一共有哪些选法呢？选0个、1个、2个……直到背包装不下了为止。</p><p>那么方程就是这样的：</p><p>dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-k<em>v[i]]+k</em>w[i])</p><p>其中k就是选j的个数，枚举即可。还是很简单对吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span><span class="hljs-number">+3</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> v[N],w[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k*v[i]&lt;=j;k++)&#123;<br>                f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-k*v[i]]+w[i]*k);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化版-1"><a href="#优化版-1" class="headerlink" title="优化版"></a>优化版</h3><p>不只是空间，这次时间复杂度也上去了，所以优化是必须的。</p><p>我们先枚举一些情况来找规律：</p><blockquote><p>f[i][j]&#x3D;max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,f[i-1][j-3v]+3w,…)<br>f[i][j-v]&#x3D;max(f[i-1][j-v],f[i-1][j-2v]+w,f[i-1][j-3v]+2w,…)<br>f[i][j-2v]&#x3D;max(f[i-1][j-2v],f[i-1][j-3v]+w,…)</p></blockquote><p>那么规律就很明显了：</p><p>f[i][j]&#x3D;max(f[i-1][j], f[i][j-v]+w)</p><p>这是一种规律上的理解，接下来说一个理解性的理解（是我个人理解的理解，所以如果你不理解也请你理解理解）</p><p>既然一个物品有多个，那么就是说当前物品可以选多个，因此不管之前选没选过都可以再选（不同于01），故而j空间获取的最大值范围就广了，不只是前i-1件可以获得的最大值，<strong>而是前i件可以获得的最大值（包括i）</strong>，因此就可以由f[i][j-v[i]]+w[i]获得。</p><p>这样的话，就包含了含有多个i的情况，并且自动地在所有可行情况中取了最大值。</p><p>以上都相当于优化了k循环，但后就是喜闻乐见地优化i循环。</p><p>具体过程就不说了，值得一提的是：记得从前往后循环，因为这次需要的dp值是第i次的，需要先进行更新。同样的，由上方方程可以得到，直接省略v[i]之前的状态是可行的，它们将默认被赋值为i-1的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span><span class="hljs-number">+3</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> v[N],w[N];<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=v[i];j&lt;=m;j++)&#123;<br>            f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><h2 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h2><p>限制背包的最大体积，给出每种物品的体积和价值，每种物品<strong>只有特定数量个</strong>，求能获得的最大价值。</p><h2 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h2><p>鉴于上面已经有了两个基础类型的铺垫，这里就不卖关子了，直接开始：</p><h3 id="基础版-2"><a href="#基础版-2" class="headerlink" title="基础版"></a>基础版</h3><p>和完全背包差不多，在k哪里多加一个限制：k≤s[i]（i的个数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span><span class="hljs-number">+3</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> v[N],w[N],s[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k*v[i]&lt;=j&amp;&amp;k&lt;=s[i];k++)&#123;<br>                f[i][j]=<span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-k*v[i]]+w[i]*k);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[n][m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是更简单了~</p><h3 id="优化版-2"><a href="#优化版-2" class="headerlink" title="优化版"></a>优化版</h3><h4 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h4><p>这里呢，我们使用<strong>二进制优化</strong>，含有倍增思想。</p><p>我们可以把每个物品的个数分成几组，每个组个数如下：</p><p>2<sup>0</sup>, 2<sup>1</sup>, 2<sup>2</sup>, 2<sup>3</sup>, …, 2<sup>k</sup>, c</p><p>2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>+2<sup>3</sup>+…+2<sup>k</sup>+c&#x3D;s</p><p>要求c&lt;2<sup>k+1</sup></p><p>那么，我们就可以凑出0~s里面所有的数了（不加c可以凑出0~2<sup>k+1</sup>-1里的所有数，加c可以凑出c~s里的所有数，又因c&lt;2<sup>k+1</sup>，所以满足条件）。</p><p>因此，我们只需要让k遍历这些组即可，可以凑出所有情况，那么就一定能求得正确的最大值。</p><p>然后呢，我们的问题就变成了解决一个<strong>大小为nlogs</strong>的<strong>01背包</strong>（倍增性质，2<sup>i</sup>每个都只需要选一次，就能凑出所有可能）</p><p>最后顺便把第一维优化了，这个不必多说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">12000</span>,M=<span class="hljs-number">2005</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> v[N],w[N],f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> a,b,s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k&lt;=s)&#123;<br>            cnt++;<br>            v[cnt]=a*k;<br>            w[cnt]=b*k;<br>            s-=k;<br>            k*=<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s)&#123;<br>            cnt++;<br>            v[cnt]=a*s;<br>            w[cnt]=b*s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    n=<span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>            f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h4><p>基础的话只学习二进制优化应该就够<del>（呛）</del>了，所以就不放单调队列优化了，有时间写一篇提高版的话可以顺带着提一嘴。</p><h1 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h1><h2 id="要求-3"><a href="#要求-3" class="headerlink" title="要求"></a>要求</h2><p>限制背包的最大体积，给出每种物品的体积和价值，其中分成了很多组，每组物品<strong>最多只选一个</strong>，求能获得的最大价值。</p><h2 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h2><p>其实很简单啊，我们把每一组都视作一个物品，但是这个物品有很多种vw组合，然后直接用01背包做就行了。</p><p>可能有一点点抽象，但是看了代码就茅塞顿开。<del>这部分比二进制优化好做多了</del></p><p>这里的优化就是最简单的滚动数组，不做解释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> s[N],v[N][N],w[N][N];<br><span class="hljs-type">int</span> f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;s[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=s[i];k++)&#123;<br>            cin&gt;&gt;v[i][k]&gt;&gt;w[i][k];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=s[i];k++)&#123;<br>                <span class="hljs-keyword">if</span>(v[i][k]&lt;=j)&#123;<br>                    f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;f[m];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>倍增</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Chinese_Remainder_Theorem中国剩余定理</title>
    <link href="/2024/08/07/Chinese-Remainder-Theorem/"/>
    <url>/2024/08/07/Chinese-Remainder-Theorem/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>刚打完cf，当前时间1:04。</p><p>链接就不放了，照着标签去找吧，总能找到的。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><h2 id="互质"><a href="#互质" class="headerlink" title="互质"></a>互质</h2><p>若m<sub>1</sub>, m<sub>2</sub>, m<sub>3</sub>, …, m<sub>k</sub>两两互质</p><p>满足如下条件：</p><blockquote><p>x≡a<sub>1</sub>(mod m<sub>1</sub>)<br>x≡a<sub>2</sub>(mod m<sub>2</sub>)<br>x≡a<sub>3</sub>(mod m<sub>3</sub>)<br>…<br>x≡a<sub>k</sub>(mod m<sub>k</sub>)</p></blockquote><p>设M&#x3D;m<sub>1</sub>m<sub>2</sub>m<sub>3</sub>…m<sub>k</sub></p><p>M<sub>i</sub>&#x3D;M&#x2F;m<sub>i</sub>，就是除了m<sub>i</sub>外所有m的乘积。</p><p>因为所有m两两互质，所以M<sub>i</sub>与m<sub>i</sub>互质。</p><p>所以，我们就可以求出M<sub>i</sub><sup>-1</sup>(mod m<sub>i</sub>)，因为互质，所以存在。由于m<sub>i</sub>不一定是质数，这里使用<strong>拓展欧几里得算法</strong>。</p><p>这里我们先给出x，然后再解释：<br>x&#x3D;a<sub>1</sub>M<sub>1</sub>M<sub>1</sub><sup>-1</sup>+a<sub>2</sub>M<sub>2</sub>M<sub>2</sub><sup>-1</sup>+a<sub>3</sub>M<sub>3</sub>M<sub>3</sub><sup>-1</sup>+…+a<sub>k</sub>M<sub>k</sub>M<sub>k</sub><sup>-1</sup></p><p>为什么呢？根据乘法逆元的定义，可以得到：M<sub>i</sub>M<sub>i</sub><sup>-1</sup>≡1(mod m<sub>i</sub>)</p><p>然后，除了第i项之外，其它项内都含有m<sub>i</sub>这个因数，模m<sub>i</sub>都为0。</p><p>所以最后模的结果就是a<sub>i</sub>%m<sub>i</sub>。</p><p>满足条件。</p><h3 id="不互质"><a href="#不互质" class="headerlink" title="不互质"></a>不互质</h3><p>M是所有m<sub>i</sub>的最小公倍数。</p><p>然后都一样。</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><del>明天再补，我真不想变成国家一级保护废物。</del></p><p>两点睡，七点起，笑死根本睡不醒。</p><p>暂停数论更新，给自己放个假，去动态规划了~</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>数学</tag>
      
      <tag>拓展欧几里得算法</tag>
      
      <tag>乘法逆元</tag>
      
      <tag>质数</tag>
      
      <tag>中国剩余定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Linear_Congruence_Equation线性同余方程</title>
    <link href="/2024/08/06/Linear-Congruence-Equation/"/>
    <url>/2024/08/06/Linear-Congruence-Equation/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>形如ax≡b(mod m)的方程</p><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p><a href="https://githarlem.github.io/2024/08/06/Bezouts-Lemma/">[编程笔记]-Bezout’s_Lemma裴蜀定理</a><br><em>（乘法逆元页面尚未创建，可以去快速幂看看概念）</em><br><a href="https://githarlem.github.io/2024/08/06/Extended-Euclidean-Algorithm/">[编程笔记]-Extended_Euclidean_Algorithm拓展欧几里得算法</a></p><h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><p>暂时没时间写，等把乘法逆元搞出来再写吧。</p><h2 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h2><p>线性同余方程等价于<br>ax&#x3D;my+b(y∈Z)<br>ax-my&#x3D;b</p><p>设y’&#x3D;-y</p><p>ax+my’&#x3D;b</p><p>根据裴蜀定理，对于任意不全为0的x、y，gcd(a,b)|ax+by</p><p>那么，只要gcd(a,m)|b，就一定有解；反之，则一定无解。</p><p>只要它有解，就可以用拓展欧几里得算法求出一个解，使ax+my’&#x3D;gcd(a, m)&#x3D;d，记作x<sub>0</sub>、y<sub>0</sub></p><p>而只要把等式右边化作b即可，所以左右两边各乘b&#x2F;d</p><p>(x<sub>0</sub>*b&#x2F;d)a+(y<sub>0</sub>*b&#x2F;d)m&#x3D;b</p><p>这样就得到了一组x、y’的解。如果需要y取相反数即可。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>鉴于有些抽象，这里直接给出一道例题。<br><a href="https://www.acwing.com/problem/content/880/">AcWing878-线性同余方程</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a,b,m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>    y-=a/b*x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(a,m,x,y);<br>        <span class="hljs-keyword">if</span>(b%d!=<span class="hljs-number">0</span>)cout&lt;&lt;<span class="hljs-string">&quot;impossible\n&quot;</span>;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;(ll)x*(b/d)%m&lt;&lt;endl;<span class="hljs-comment">//题目要求在int范围内，所以直接%一个m就行，满足条件。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>数学</tag>
      
      <tag>裴蜀定理</tag>
      
      <tag>拓展欧几里得算法</tag>
      
      <tag>乘法逆元</tag>
      
      <tag>线性同余方程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Extended_Euclidean_Algorithm拓展欧几里得算法</title>
    <link href="/2024/08/06/Extended-Euclidean-Algorithm/"/>
    <url>/2024/08/06/Extended-Euclidean-Algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>在学习拓展欧几里得算法前，建议先阅读裴蜀定理和乘法逆元两个页面了解本算法的作用。<br><a href="https://githarlem.github.io/2024/08/06/Bezouts-Lemma/">[编程笔记]-Bezout’s_Lemma裴蜀定理</a><br><em>（乘法逆元页面尚未创建，可以去快速幂看看概念）</em></p><p>另外，如果你不知道欧几里得算法（辗转相除法），建议去约数基础部分先学习一下。<br><a href="https://githarlem.github.io/2024/08/05/Divisor-Basis/">[编程笔记]-Divisor_Basis约数基础</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先，既然是拓展欧几里得算法，肯定要从欧几里得算法拓展。</p><p>这里直接给出（证明见欧几里得算法）：gcd(a, b)&#x3D;&#x3D;gcd(b, a%b)</p><p>已知当b&#x3D;&#x3D;0时，gcd(a,b)&#x3D;a。</p><p>拓展欧几里得算法就是要找非零整数x, y，使得**ax+by&#x3D;gcd(a, b)**嘛（证明裴蜀定理），那么b&#x3D;&#x3D;0时，x&#x3D;1，b本来应该是任意数，这里特殊设置为0。</p><p>好，那么接下来就开始模拟递归返回的过程了——</p><p>假设我们按照定义写代码，下一层递归中的x、y记作x&#39;、y&#39;，可以得到：</p><p>若当前函数是gcd(a, b)，那么它的下一层递归也就应该是gcd(b, a%b)。</p><p>那么根据欧几里得定理，gcd(b, a%b)&#x3D;&#x3D;gcd(a, b)，这里把它们记作d。</p><p>又根据裴蜀定理，可得b*x&#39;+(a%b)*y&#39;&#x3D;&#x3D;d</p><p>这里讲一下%的展开方法：a%b&#x3D;a-⌊a&#x2F;b⌋*b</p><p>然后把得到的式子展开并重新整理：<br>y&#39;*a+(x&#39;-y&#39;*⌊a&#x2F;b⌋)*b&#x3D;&#x3D;d</p><p>这个表达式表示的是gcd(b, a%b)得到的式子，也就是这一层递归的下一层递归得到的式子。</p><p>而在这一层递归中，x*a+y*b&#x3D;&#x3D;d，</p><p>因此x&#x3D;y&#39;, y&#x3D;x&#39;-y&#39;*⌊a&#x2F;b⌋</p><p>刚递归回溯到这一层时x、y实际是x&#39;、y&#39;，那如果在传参数的时候互换一下，x、y实际就成了y&#39;、x&#39;，那么就可以得出x、y的更新代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">exgcd</span>(b, a%b, y, x);<br><span class="hljs-comment">//x不变</span><br>y=y-a/b*x<span class="hljs-comment">//鉴于运算顺序从左往右，要求先向下取整再运算，如果先乘了的话会出现误差，当然加个括号也行。</span><br></code></pre></td></tr></table></figure><p>然后啊，经过验证，裴蜀定理就成立了。</p><p>说实话这个根据需要证明的定理构造过程在运用需要证明的定理方式下通过结果证明了需要证明的定理的定理证明方式还是有点不好理解的，甚至新接触数论的蒟蒻们（包括我TAT）会感受到这有一点逻辑悖论的味道。</p><p>那么重点就在于程序的完成了。</p><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        x=<span class="hljs-number">1</span>;y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<br>    y-=a/b*x;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="通解"><a href="#通解" class="headerlink" title="通解"></a>通解</h1><p>另外，x、y是不唯一的，求通解如下：</p><p>已知ax<sub>0</sub>+by<sub>0</sub>&#x3D;&#x3D;d</p><p>那么ax<sub>0</sub>+by<sub>0</sub>-(a*b)&#x2F;d+(a*b)&#x2F;d&#x3D;&#x3D;d（(a*b)&#x2F;d定为整数，因为d是最大公约数。）</p><p>化得a(x<sub>0</sub>-b&#x2F;d)+b(y<sub>0</sub>+a&#x2F;d)&#x3D;&#x3D;d</p><p>那么就可以得到通解:<br>x&#x3D;x<sub>0</sub>-b&#x2F;d*k,(k∈Z)<br>y&#x3D;y<sub>0</sub>+a&#x2F;d*k,(k∈Z)</p><h1 id="求乘法逆元"><a href="#求乘法逆元" class="headerlink" title="求乘法逆元"></a>求乘法逆元</h1><p>其实就是求解线性同余方程的特殊情况（b&#x3D;1），看线性同余方程就行了。<br><a href="https://githarlem.github.io/2024/08/06/Linear-Congruence-Equation/">[编程笔记]-Linear_Congruence_Equation线性同余方程</a></p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1><p>跟着醉酒·y总走了三遍没走明白，然后才想起来y总喝醉了Σ(っ °Д °;)っ<br>然后就在评论区里搞懂哩，以为自己学的有问题，想了好久(ノへ￣、)</p>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>数学</tag>
      
      <tag>裴蜀定理</tag>
      
      <tag>最大公约数</tag>
      
      <tag>拓展欧几里得算法</tag>
      
      <tag>乘法逆元</tag>
      
      <tag>欧几里得算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Bezout&#39;s_Lemma裴蜀定理</title>
    <link href="/2024/08/06/Bezouts-Lemma/"/>
    <url>/2024/08/06/Bezouts-Lemma/</url>
    
    <content type="html"><![CDATA[<h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><h2 id="gcd-a-b-ax-by"><a href="#gcd-a-b-ax-by" class="headerlink" title="gcd(a,b)|ax+by"></a>gcd(a,b)|ax+by</h2><p>a、b都是是gcd(a,b)的倍数，对于任意不全为零整数x、y所以gcd(a,b)|ax+by</p><p>因此a、b能凑出来的最小的数就是它的最大公约数。</p><h2 id="ax-by-gcd-a-b"><a href="#ax-by-gcd-a-b" class="headerlink" title="ax+by&#x3D;gcd(a, b)"></a>ax+by&#x3D;gcd(a, b)</h2><p>对于任意正整数a, b，一定存在非零整数x, y，使得ax+by&#x3D;gcd(a, b)</p><p>证明：我们可以使用<strong>构造法</strong></p><p>构造出一种方式，对于任意正整数a, b，一定存在非零整数x, y，使得ax+by&#x3D;gcd(a, b)，呢么就可以证明这个公式成立了。</p><p>这个方法就是拓展欧几里得算法。<br><a href="https://githarlem.github.io/2024/08/06/Extended-Euclidean-Algorithm/">[编程笔记]-Extended_Euclidean_Algorithm拓展欧几里得算法</a></p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>数学</tag>
      
      <tag>裴蜀定理</tag>
      
      <tag>最大公约数</tag>
      
      <tag>拓展欧几里得算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Binary_Exponentiation快速幂</title>
    <link href="/2024/08/05/Binary-Exponentiation/"/>
    <url>/2024/08/05/Binary-Exponentiation/</url>
    
    <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>把a的k次方分解成a的（2的次方）次方之积。</p><p>也就是把k分成2的不同次方相加嘛。容易得到，2的每个次方最多只会出现一次（不然就能<del>进位</del>算进更高一次的次方里面去了）。</p><p>差不多就是这样。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(logk)（k为幂数）</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>很简单，根据思想就能得出。<br>每次都把次方平均分，如果是奇数，就在结果处额外乘一个n即可，然后递归次方的二分之一，直到0次方。</p><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>事实上，可以把次数写出二进制写法，然后就可以根据每一位上是否为1分出不同的加项了。</p><p>每次幂次左移一位，不要忘了把底数平方一次（实现一次平方），然后根据当前幂次的二进制最低位来判断是否要乘入结果。</p><p>可能讲的不是很清楚，但差不多应该也讲清了思路，带着代码可能更好理解。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> t=<span class="hljs-built_in">qm</span>(a,b/<span class="hljs-number">2</span>,p);<br>    <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> (ll)t*t%p;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">return</span> (ll)t*t*a%p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：实测这份代码的精度没有下面那份高，速度也不够好，所以还是推荐迭代法。</p><h1 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)res=(ll)res*a%p;<br>        a=(ll)a*a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="应用——乘法逆元"><a href="#应用——乘法逆元" class="headerlink" title="应用——乘法逆元"></a>应用——乘法逆元</h1><p>以后应该会专门写一篇介绍乘法逆元，<del>到时候就把这部分复制过去</del>这里就顺便介绍一下，专门讲用快速幂解决的方法。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>若b与m互质</strong>，满足b|a，a&#x2F;b≡ax(mod m)，则称x为b模m的逆元，记作b<sup>-1</sup>（是标记，不是b的-1次方，可以是整数）</p><p>然后就可以把÷b的情况转化为×b的逆元的情况，在编程中，这就准确多了。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><blockquote><p>a&#x2F;b≡ab<sup>-1</sup> (mod m)</p><p>b*a&#x2F;b≡b*ab<sup>-1</sup> (mod m)</p><p>a≡a*b*b<sup>-1</sup> (mod m)</p><p>-&gt; b*b<sup>-1</sup>≡1 (mod m)</p></blockquote><p>（最后一步的条件是a%m!&#x3D;0，虽然a与m不一定互质，但由于a有b这个和m互质的质因子，所以a%m!&#x3D;0）</p><p>即为:<br><strong>bx≡1 (mod m)</strong></p><p>公式美化：<strong>ax≡1 (mod m)</strong></p><h2 id="计算逆元"><a href="#计算逆元" class="headerlink" title="计算逆元"></a>计算逆元</h2><p>在快速幂求解过程中中，一般要求m为质数。</p><p>因此，ax≡1 (mod p)</p><p>根据<strong>费马小定理</strong>，a<sup>p-1</sup>≡1 (mod p)</p><p>然后把根据费马小定理的这个式子拆出来一个<br>a：a*a<sup>a-2</sup>≡1 (mod p)</p><p>所以a<sup>p-2</sup>&#x3D;x，就是a模p的逆元。</p><p>又因p是质数，所以p&gt;&#x3D;2，因此p-2&gt;&#x3D;0。</p><p><strong>因此，求a模p的逆元，也就是求a<sup>p-2</sup></strong></p><p><strong>但是，若p与a不互质，则无解，因为不可能出现余数。同时，这也是费马小定理使用前提和乘法逆元定义中的一部分。</strong></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">int</span> n,a,p;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> q)</span></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)res=(ll)res*a%p;<br>        a=(ll)a*a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;a&gt;&gt;p;<br>        <span class="hljs-keyword">if</span>(a%p!=<span class="hljs-number">0</span>)cout&lt;&lt;<span class="hljs-built_in">qmi</span>(a,p<span class="hljs-number">-2</span>,p)&lt;&lt;endl;<span class="hljs-comment">//由于p是质数，所以二者不互质就只有倍数关系</span><br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>数学</tag>
      
      <tag>倍增</tag>
      
      <tag>快速幂</tag>
      
      <tag>乘法逆元</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Fermat&#39;s_Little_Theorem费马小定理</title>
    <link href="/2024/08/05/Fermats-Little-Theorem/"/>
    <url>/2024/08/05/Fermats-Little-Theorem/</url>
    
    <content type="html"><![CDATA[<h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>若p为质数，a<sup>p-1</sup>≡1(mod p)</p><h1 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h1><p>根据欧拉函数，a<sup>φ(p)</sup>≡1(mod p)</p><p>然后当p为质数时，φ(p)&#x3D;p-1（详见欧拉函数）</p><p>所以，a<sup>p-1</sup>≡1(mod p)</p><p>（如果您不会欧拉函数就来的话，我相信您看不懂φhhh）</p><p><a href="https://githarlem.github.io/2024/08/05/Eulers-Totient-Function/">[编程笔记]-Euler’s_Totient_Function欧拉函数</a></p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>数学</tag>
      
      <tag>质数</tag>
      
      <tag>费马小定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Euler&#39;s_Totient_Function欧拉函数</title>
    <link href="/2024/08/05/Eulers-Totient-Function/"/>
    <url>/2024/08/05/Eulers-Totient-Function/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>φ(n)表示1~n之中与n互质的数的个数</p><p>令N&#x3D;P<sub>1</sub><sup>α<sub>1</sub></sup>*P<sub>2</sub><sup>α<sub>2</sub></sup>*P<sub>3</sub><sup>α<sub>3</sub></sup>*…*P<sub>k</sub><sup>α<sub>k</sub></sup></p><p>则φ(N)&#x3D;N(1-1&#x2F;P<sub>1</sub>)(1-1&#x2F;P<sub>2</sub>)(1-1&#x2F;P<sub>3</sub>)…(1-1&#x2F;P<sub>k</sub>)</p><h1 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h1><ol><li>求出N的质因数</li><li>从1~N中去掉P<sub>1</sub>，P<sub>2</sub>到P<sub>k</sub>的倍数。</li><li>加上所有P<sub>i</sub>*P<sub>j</sub>的倍数，因为第二步把它们多减了一次。</li><li>减去所有P<sub>i</sub>*P<sub>j</sub>*P<sub>k</sub>的倍数，因为第三步把它们多加了一次……</li></ol><p><img src="/2024/08/05/Eulers-Totient-Function/P1.png" alt="手搓示意图1"></p><p><img src="/2024/08/05/Eulers-Totient-Function/P2.png" alt="手搓示意图2"></p><p>可得：</p><p><strong>容斥原理</strong><br>N-N&#x2F;P<sub>1</sub>-N&#x2F;P<sub>2</sub>-N&#x2F;P<sub>3</sub>-…-N&#x2F;P<sub>k</sub><br>  +N&#x2F;P<sub>1</sub>P<sub>2</sub>+N&#x2F;P<sub>1</sub>P<sub>3</sub>+…+N&#x2F;P<sub>k-1</sub>P<sub>k</sub><br>  -N&#x2F;P<sub>1</sub>P<sub>2</sub>P<sub>3</sub>-…-N&#x2F;P<sub>k-2</sub>P<sub>k-1</sub>P<sub>k</sub><br>  +…<br>归纳得：</p><p>φ(N)&#x3D;N(1-1&#x2F;P<sub>1</sub>)(1-1&#x2F;P<sub>2</sub>)(1-1&#x2F;P<sub>3</sub>)…(1-1&#x2F;P<sub>k</sub>)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">105</span>;<br><br><span class="hljs-type">int</span> res;<br><span class="hljs-type">int</span> n,a;<br><span class="hljs-type">int</span> prime[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;a;<br>        <span class="hljs-type">int</span> res=a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=a/i;i++)&#123;<br>            <span class="hljs-keyword">if</span>(a%i==<span class="hljs-number">0</span>)&#123;<br>                res=res/i*(i<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">while</span>(a%i==<span class="hljs-number">0</span>)a/=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">1</span>)res=res/a*(a<span class="hljs-number">-1</span>);<br>        cout&lt;&lt;res&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要是不会线性筛，就请先学一下先：<br><a href="https://githarlem.github.io/2024/08/05/Prime-Basis/">[编程笔记]-Prime_Basis质数基础</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>特殊但不是很特殊地，φ(1)&#x3D;1，因为1本身也与1互质。</p><p>当x为质数时，φ(x)&#x3D;x-1</p><p>对于每个x&#x3D;P<sub>j</sub>*i：</p><ol><li>若i%P<sub>j</sub>&#x3D;&#x3D;0，那么P<sub>j</sub>就是i的最小质因子，因此x的质因子就是i的质因子。所以，φ(x)&#x3D;P<sub>j</sub>*φ(i)。（详细：由于质因子相同，所以两个欧拉函数除了开头”N”部分都一样，而x也就是P<sub>j</sub>*i，所以就是P<sub>j</sub>*i*[函数后部分]，即P<sub>j</sub>*φ(i)）</li><li>若i%P<sub>j</sub>!&#x3D;0，那么P<sub>j</sub>就不是i的质因子，但是i*P<sub>j</sub>的最小质因子。因为P<sub>j</sub>是质数，所以它的质因子只有它本身。φ(P<sub>j</sub>*i)&#x3D;P<sub>j</sub>*i*[i的欧拉函数剩余部分]*(1-1&#x2F;P<sub>j</sub>)，也就等同于φ(P<sub>j</sub>)*φ(i)，或者是(P<sub>j</sub>-1)*φ(i)。</li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, phi[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">euler</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> prime[N];<br>    <span class="hljs-type">bool</span> st[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            prime[++cnt]=i;<br>            phi[i]=i<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;prime[j]&lt;=n/i;j++)&#123;<br>            st[prime[j]*i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)&#123;<br>                phi[prime[j]*i]=prime[j]*phi[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            phi[prime[j]*i]=phi[prime[j]]*phi[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>若a与n互质，a<sup>φ(n)</sup>≡1(mod n)</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>若在1~n中，所有与n互质的数为a<sub>1</sub>, a<sub>2</sub>, …a<sub>φ(n)</sub></p><p>又因a与n互质，</p><p>所以a*a<sub>1</sub>, a*a<sub>2</sub>, …a*a<sub>φ(n)</sub> 都满足≡1(mod n)</p><p>并且在这个序列里，产生的数两两各不相同。</p><p>证明如下：</p><blockquote><p>反证法，若a*a<sub>i</sub>≡a*a<sub>j</sub>(mod n)<br>则a(a<sub>i</sub>-a<sub>j</sub>)≡0(mod n)<br>因a与n互质，可得：<br>a<sub>i</sub>-a<sub>j</sub>≡0(mod n)<br>a<sub>i</sub>≡a<sub>j</sub>(mod n)<br>但a<sub>i</sub>, a<sub>j</sub>都是n的不同的质因数，因此不成立。</p></blockquote><p>因此，新序列也是φ(n)个互不相同且与n互质的数。</p><p>那么就可以得到（毕竟与n互质的数只有φ(n)个）：前后两个序列，内部元素（mod n后）其实是一样的，就是顺序可能会有所不同，所以它们乘积也应该同余。</p><p>那么易得：</p><p>a<sup>φ(n)</sup>(a<sub>1</sub>*…*a<sub>φ(n)</sub>)≡a<sub>1</sub>*…*a<sub>φ(n)</sub>(mod n)</p><p>又因a<sub>i</sub>都是n的质因数，所以，(a<sub>1</sub>*…*a<sub>φ(n)</sub>)也就是n的质因数。</p><p>所以a<sup>φ(n)</sup>≡1(mod n)</p><p>别忘了a与n互质。</p><h2 id="简单推论——费马小定理"><a href="#简单推论——费马小定理" class="headerlink" title="简单推论——费马小定理"></a>简单推论——费马小定理</h2><p>当n为质数时，a<sup>φ(p)</sup>≡1(mod p)</p><p>则，a<sup>p-1</sup>≡1(mod p)</p><p>别忘了a与p互质。</p><p>没错这就是<strong>费马小定理</strong>。</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>数学</tag>
      
      <tag>质数</tag>
      
      <tag>欧拉函数</tag>
      
      <tag>线性筛</tag>
      
      <tag>欧拉定理</tag>
      
      <tag>费马小定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Divisor_Basis约数基础</title>
    <link href="/2024/08/05/Divisor-Basis/"/>
    <url>/2024/08/05/Divisor-Basis/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>x的约数其实就是能整除x的正整数。</p><p>例：4的约数有{1,2,4}。</p><h1 id="求约数。"><a href="#求约数。" class="headerlink" title="求约数。"></a>求约数。</h1><p>对，没错，还是试除法。</p><p>不会可以看看质数基础（？）<br><a href="https://githarlem.github.io/2024/08/05/Prime-Basis/">[编程笔记]-Prime_Basis质数基础</a></p><p>O(sqrt(n))</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_dvs</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(num%i==<span class="hljs-number">0</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span>(num/i!=i)res.<span class="hljs-built_in">push_back</span>(num/i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>算数基本定理：<br>N&#x3D;P1<sup>a1</sup><em>P2<sup>a2</sup></em>…*Pk<sup>ak</sup></p><p>那么N的约数个数是(a1+1)(a2+1)…(ak+1)</p><h2 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h2><p>令d为N的约数，则有</p><p>d&#x3D;P1<sup>b1</sup><em>P2<sup>b2</sup></em>…*Pk<sup>bk</sup></p><p>(0&lt;&#x3D;bi&lt;&#x3D;ai)</p><p>就是<strong>分解质因数</strong><br><a href="https://githarlem.github.io/2024/08/05/Prime-Basis/">[编程笔记]-Prime_Basis质数基础</a></p><p>所以枚举所有情况就好了。每一个b都有(a+1)种情况，然后乘法定理。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.acwing.com/problem/content/872/">AcWing870-约数个数</a><br>由于公式是乘法，题目要求中也是乘法，就相当于看作同一个数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span><span class="hljs-number">+7</span>;<br><br><span class="hljs-type">int</span> n,a;<br>ll ans=<span class="hljs-number">1</span>;<br>unordered_map&lt;<span class="hljs-type">int</span>,ll&gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=a/i;i++)&#123;<br>            <span class="hljs-keyword">while</span>(a%i==<span class="hljs-number">0</span>)&#123;<br>                a/=i;<br>                mp[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">1</span>)mp[a]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:mp)&#123;<br>        ans=ans*(p.second<span class="hljs-number">+1</span>)%mod;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h1><p>(p1<sup>0</sup>+p1<sup>1</sup>+p1<sup>2</sup>+…+p1<sup>a1</sup>)<em>…</em>(pk<sup>0</sup>+pk<sup>1</sup>+pk<sup>2</sup>+…+pk<sup>ak</sup>)</p><p>把这个公式展开，就是所有情况的约数相加了。</p><p>求上面那个公式：<br>重复a次t&#x3D;p*t+1</p><p>t初始为1</p><ol><li>t&#x3D;p+1</li><li>t&#x3D;p<sup>2</sup>+p+1</li><li>t&#x3D;p<sup>3</sup>+p<sup>2</sup>+p+1<br>…</li></ol><p>然后就没有然后了</p><p><a href="https://www.acwing.com/problem/content/873/">AcWing871-约数之和</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span><span class="hljs-number">+7</span>;<br><br><span class="hljs-type">int</span> n,a;<br>ll ans=<span class="hljs-number">1</span>;<br>unordered_map&lt;<span class="hljs-type">int</span>,ll&gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=a/i;i++)&#123;<br>            <span class="hljs-keyword">while</span>(a%i==<span class="hljs-number">0</span>)&#123;<br>                a/=i;<br>                mp[i]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">1</span>)mp[a]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pa:mp)&#123;<br>        <span class="hljs-type">int</span> p=pa.first,a=pa.second;<br>        ll t=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(a--)t=(t*p<span class="hljs-number">+1</span>)%mod;<br>        ans=ans*t%mod;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最大公约数——欧几里得算法"><a href="#最大公约数——欧几里得算法" class="headerlink" title="最大公约数——欧几里得算法"></a>最大公约数——欧几里得算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>欧几里得算法（Euclidean Algorithm），也叫辗转相除法（是不是熟悉多哩(￣︶￣)），主要用来解决最大公约数（最大公因数）问题。</p><p><em>tips: __gcd()应该也是用这个的吧</em></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><code>gcd(a, b)=gcd(b, a%b)</code></p><p>若d|x, d|y, 则d|ax+by</p><p>a%b&#x3D;&#x3D;a-c*b</p><p>令a,b最大公约数为d1，则d1|a, d1|b, 所以d1|a-c*b，即d1|a%b。</p><p>令b,a%b最大公约数为d2，则d2|b, d2|a-c*b, 所以d2|a-c*b+c*b，即d2|a。</p><p>因此，二者的公约数全部相同，最大公约数也相同。</p><p>特殊但其实不特殊地，当b&#x3D;&#x3D;0时，最大公约数是a，因为0可以被任何数整除都余0。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b,a%b):a;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1><p><em>骚年，你已经打开了通往数论的大门，走上了这条不归路了（〒▽〒）</em></p>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>数学</tag>
      
      <tag>最大公约数</tag>
      
      <tag>约数</tag>
      
      <tag>欧几里得算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Prime_Basis质数基础</title>
    <link href="/2024/08/05/Prime-Basis/"/>
    <url>/2024/08/05/Prime-Basis/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>进入数学部分了</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>质数，指的是大于1的只有1和本身两个因数的数，又叫素数。</p><h1 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h1><h2 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h2><h3 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h3><p>就是把所有二以上的数一个一个试，时间复杂度O(n)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;num;i++)&#123;<br>        <span class="hljs-keyword">if</span>(num%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，太慢了。</p><h3 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h3><h4 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h4><p>若d为n约数，那么n&#x2F;d也为n约数。所以d和n&#x2F;d成对出现。因此我们只需要枚举每一对中较小的元素，整理得：<br><code>d*d&lt;=n</code></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>O(sqrt(n))</p><h4 id="写法推荐"><a href="#写法推荐" class="headerlink" title="写法推荐"></a>写法推荐</h4><ol><li>i&lt;&#x3D;sqrt(n)，不推荐，每次都要执行一次sqrt，很慢。</li><li>i*i&lt;&#x3D;n，不推荐，如果n足够大，很容易溢出。</li><li>i&lt;&#x3D;n&#x2F;i，推荐，不会溢出，也足够快。</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=num/i;i++)&#123;<br>        <span class="hljs-keyword">if</span>(num%i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他判定方法"><a href="#其他判定方法" class="headerlink" title="其他判定方法"></a>其他判定方法</h2><p>一般优化的就是各种质数筛，什么线性筛、埃氏筛之类的，详见下方质数筛部分。</p><p>更高阶的算法，肯定不在这里讲。</p><h1 id="分解因数"><a href="#分解因数" class="headerlink" title="分解因数"></a>分解因数</h1><h2 id="试除法-1"><a href="#试除法-1" class="headerlink" title="试除法"></a>试除法</h2><p>没错还是它，质数运算的简单暴力算法——试除法。</p><h3 id="基础版-1"><a href="#基础版-1" class="headerlink" title="基础版"></a>基础版</h3><p>从2开始一直试到n，每次都去让n除以这个数，除到没法除为止，每次的除数就是一个因数。然后接着下一个数。</p><p>时间复杂度O(n)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dpf</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=num;i++)&#123;<br>        <span class="hljs-keyword">while</span>(num%i==<span class="hljs-number">0</span>)&#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>            num/=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> vec;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优化版-1"><a href="#优化版-1" class="headerlink" title="优化版"></a>优化版</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>n中最多只包含一个大于sqrt(n)的质因子。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>反证法，要是有两个，乘起来就大于n了不是吗hh</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>那么因数就枚举到sqrt(n)即可。若最后n&gt;1，那么n自己就是那个大于sqrt(n)的质因子。</p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最好O(logn)，最坏O(sqrt(n))</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dpf</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=num/i;i++)&#123;<br>        <span class="hljs-keyword">while</span>(num%i==<span class="hljs-number">0</span>)&#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i);<br>            num/=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">1</span>)vec.<span class="hljs-built_in">push_back</span>(num);<br>    <span class="hljs-keyword">return</span> vec;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h1><h2 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h2><p>先创建一个质数序列，从2开始，一开始所有数都在里面。</p><p>然后从2一个一个往后走，每一次都把它所有倍数从序列里筛掉。</p><p>O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_prime_num</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> prime[N];<br>    <span class="hljs-type">bool</span> st[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            prime[++cnt]=i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;i*j&lt;=n;j++)&#123;<br>            st[i*j]=<span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="埃氏筛-Eratosthenes"><a href="#埃氏筛-Eratosthenes" class="headerlink" title="埃氏筛(Eratosthenes)"></a>埃氏筛(Eratosthenes)</h2><p>只有质数需要把所有倍数筛掉。</p><p>O(nloglogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_prime_num</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> prime[N];<br>    <span class="hljs-type">bool</span> st[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])&#123;<br>            prime[++cnt]=i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;i*j&lt;=n;j++)&#123;<br>                st[i*j]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线性筛-Euler"><a href="#线性筛-Euler" class="headerlink" title="线性筛(Euler)"></a>线性筛(Euler)</h2><h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><p>也是从2枚举到n（令当前为i），如果i没有被筛掉，就添加为质数。</p><p><strong>但不管是不是质数，都进行一次循环，遍历当前所有不大于n&#x2F;i的质数，把他们的i倍筛掉。若当前质数是i的因数，退出循环。</strong></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>线性筛中，<strong>n只会被最小质因子筛掉</strong></p><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>情况1：i%pj&#x3D;&#x3D;0</p><p>因为是从小到大枚举的所有质数，所以pj一定是i的最小质因子，pj也就一定是pj*i的最小质因子。</p><p>情况2：i%pj!&#x3D;0</p><p>同理，pj一定小于i的最小质因子，pj也就一定是pj*i的最小质因子。</p><hr><p>对于一个合数x，假设pj是x的最小质因子，那么当i枚举到x&#x2F;pj，就会把x筛掉。</p><p>之所以遍历所有不大于n&#x2F;i的质数，是为了pj*i不超过最大数n…</p><p>当i%pj&#x3D;&#x3D;0时，那么之后的比pj大的质数就大于i的最小质因数了，因为<strong>n只会被最小质因子筛掉</strong>，而<code>n=pj*i</code>，因此i的最小质因数才是n的最小质因数，所以直接退出循环即可。</p><p>之所以不用添加j&lt;&#x3D;cnt：当i为质数，当pj&#x3D;&#x3D;i时自己会停下。当i为合数，当pj是i的最小质因数时会停下，而i之前所有质数都是已经确定了的，i之后的也不会遇到。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(n)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_prime_num</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> prime[N];<br>    <span class="hljs-type">bool</span> st[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=num;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!st[i])prime[++cnt]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;prime[j]&lt;=n/i;j++)&#123;<br>            st[prime[j]*i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数学知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>数学</tag>
      
      <tag>质数</tag>
      
      <tag>线性筛</tag>
      
      <tag>质数筛</tag>
      
      <tag>埃氏筛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Bipartite_Graph_Maximum_Match(Hungary_Algorithm)二分图最大匹配（匈牙利算法）</title>
    <link href="/2024/08/04/Bipartite-Graph-Maximum-Match-Hungary-Algorithm/"/>
    <url>/2024/08/04/Bipartite-Graph-Maximum-Match-Hungary-Algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h1><p>就是求出在二分图中，最多有多少对点能完成匹配。</p><p>有时还会让你输出方案。</p><p><strong>更高级的其实是带权的匹配问题，但鉴于这篇博客本意不在于此，所以就只讲解匈牙利算法了。</strong></p><p><strong>当然还有更高级的<del>我忘了</del>，到时候再说吧。</strong></p><h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><p>其实很简单，以左侧点为基准，对于每个点，尝试每个与它相连的右侧点：</p><p>如果右侧点没有匹配，那就直接上；如果右侧点有匹配了，就让跟它匹配的左侧点尝试找别的可以匹配的点（也就是递归），成了，就让那个点换一个匹配点，然后自己匹配上去；不成，那就接着试下一个点。</p><p>如果一个左侧点没法连上任何右侧点，即视为无法进行匹配。在某些题型中，就是匹配失败了。</p><p><em>y总の奇妙讲解belike: 一边男的，一边女的，男的找女的，如果就可能，就让她原配换一个，然后自己上去。实在换不了，自己再换一个对象。所以人嘛都要试一试，不能轻易放弃，要克服困难~</em></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>还是上道题感受一下问法：<br><a href="https://www.acwing.com/problem/content/863/">AcWing861-二分图的最大匹配</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>,M=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> idk,hd[N],to[M],ne[M];<br><br><span class="hljs-type">int</span> n1,n2,m;<br><span class="hljs-type">int</span> u,v;<br><span class="hljs-type">bool</span> fns[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-type">int</span> ma[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    to[++idk]=b;<br>    ne[idk]=hd[a];<br>    hd[a]=idk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    fns[x]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[x];i;i=ne[i])&#123;<br>        <span class="hljs-keyword">if</span>(ma[to[i]]==<span class="hljs-number">0</span>||(!fns[ma[to[i]]]&amp;&amp;<span class="hljs-built_in">find</span>(ma[to[i]])))&#123;<br>            ma[to[i]]=x;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hungary</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(fns,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(fns));<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i))res++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;u&gt;&gt;v;<br>        <span class="hljs-built_in">merge</span>(u,v);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">hungary</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>二分图</tag>
      
      <tag>匈牙利算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Bipartite_Gragh_Determination(Staining_Method)二分图判定（染色法）</title>
    <link href="/2024/08/04/Bipartite-Gragh-Determination-Staining-Method/"/>
    <url>/2024/08/04/Bipartite-Gragh-Determination-Staining-Method/</url>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>判定一个图是不是<em>二分图</em>（可以分成左右两边、边只存在于两边之间而不在某一边内部的图）</p><p>二分图正规定义：图中不含奇数环。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>就是用DFS或BFS或其他遍历方式遍历整个图，尝试给每两个相邻点染上不同颜色，最多两色，如果成功就是二分图。</p><p>#代码<br>染色特别好理解，所以重点实在遍历上面。<br><a href="https://githarlem.github.io/2024/08/03/DFS/">[编程笔记]-DFS深度优先搜索</a><br><a href="https://githarlem.github.io/2024/08/03/BFS/">[编程笔记]-BFS广度优先搜索</a><br>（就不放代码了(～￣▽￣)～）</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>二分图</tag>
      
      <tag>染色法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Kruskal</title>
    <link href="/2024/08/04/Kruskal/"/>
    <url>/2024/08/04/Kruskal/</url>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>多在稀疏图中生成最小生成树</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li>将每条边从小到大排好序。</li><li>找到一条连接两个不同集合的边权最小的边，将其加入确定的边中。</li><li>重复n-1次，即所有点都加入了最小生成树。</li></ol><p>特殊地，判断连接的是否是两个不同集合，推荐使用并查集。<br><a href="https://githarlem.github.io/2024/08/02/Union-Find-Set/">[编程笔记]-Union_Find_Set并查集</a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>,M=<span class="hljs-number">2e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ufset</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-type">int</span> p[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            n=x;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>                p[i]=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(p[x]!=x)p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>            <span class="hljs-keyword">return</span> p[x];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            a=<span class="hljs-built_in">find</span>(a);b=<span class="hljs-built_in">find</span>(b);<br>            p[a]=b;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b);<br>        &#125;<br>&#125;ufs;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> u,v,w;<br>&#125;es[M];<br><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(edge a,edge b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.w&lt;b.w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sort</span>(es<span class="hljs-number">+1</span>,es<span class="hljs-number">+1</span>+m,cmp);<br>    ufs.<span class="hljs-built_in">init</span>(n);<br>    <span class="hljs-type">int</span> fns=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;=m&amp;&amp;ufs.<span class="hljs-built_in">same</span>(es[i].u,es[i].v))i++;<br>        <span class="hljs-keyword">if</span>(i&gt;m)<span class="hljs-keyword">break</span>;<br>        ufs.<span class="hljs-built_in">merge</span>(es[i].u,es[i].v);<br>        fns++;<br>        res+=es[i].w;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fns==n<span class="hljs-number">-1</span>)cout&lt;&lt;res;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;es[i].u&gt;&gt;es[i].v&gt;&gt;es[i].w;<br>    &#125;<br>    <span class="hljs-built_in">kruskal</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>树论</tag>
      
      <tag>最小生成树</tag>
      
      <tag>Kruskal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Prim</title>
    <link href="/2024/08/04/Prim/"/>
    <url>/2024/08/04/Prim/</url>
    
    <content type="html"><![CDATA[<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>和Dijkstra基本一模一样。</p><p>不过它每次找的是<strong>距离当前生成的树最近的节点，不是距离树根最近的节点</strong>。</p><p><a href="https://githarlem.github.io/2024/08/03/Dijkstra-Plain/">[编程笔记]-Dijkstra(Plain)迪杰斯特拉（朴素版）</a></p><ol><li>初始化：设立一个集合S（空）储存所有已在生成树中的点，并设立距离dis数组，除了起点设为0外，其他点都设为正无穷。</li><li>在所有点中，找一个不在S里并且dis最小的点t</li><li>把t加入集合S，并且更新所有与之相连的点的距离。</li><li>重复执行2、3步直到所有点都加入集合S（共执行n次）。</li></ol><p>注：Dij共迭代n-1次，因为开头指定了一个起点；但Prim并没有，所以执行n次。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>;<br><br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">bool</span> fns[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> u,v,w;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;n;t++)&#123;<br>        <span class="hljs-type">int</span> mi=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!fns[i]&amp;&amp;dis[i]&lt;dis[mi])mi=i;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(mi==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        fns[mi]=<span class="hljs-literal">true</span>;<br>        res+=dis[mi];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(g[mi][i]!=<span class="hljs-number">0x3f3f3f3f</span>)&#123;<br>                dis[i]=<span class="hljs-built_in">min</span>(dis[i],g[mi][i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>        g[u][v]=<span class="hljs-built_in">min</span>(g[u][v],w);<br>        g[v][u]=g[u][v];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">prim</span>())cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>树论</tag>
      
      <tag>最小生成树</tag>
      
      <tag>Prim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Minimum_Spanning_Tree_Problem(General)最小生成树问题总概</title>
    <link href="/2024/08/04/Minimum-Spanning-Tree-Problem-General/"/>
    <url>/2024/08/04/Minimum-Spanning-Tree-Problem-General/</url>
    
    <content type="html"><![CDATA[<h1 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h1><p>特别像Dijkstra，除了作用不一样，别的几乎都一样，甚至优化方式都一样Σ(っ °Д °;)っ</p><h2 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h2><p>时间复杂度O(n<sup>2</sup>)</p><p>通常用来解决稠密图。</p><h2 id="堆优化版"><a href="#堆优化版" class="headerlink" title="堆优化版"></a>堆优化版</h2><p><em>说实话，不常用，因为Kruskal比它好写。</em></p><p>时间复杂度O(mlogn)。</p><p>常用来解决稀疏图。</p><p><em>因为它不常用，也因为它的优化方法和Dij一样，所以就不专门讲了</em></p><h1 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h1><p>时间复杂度O(mlogm)（和O(mlogn)同一个量级）。</p><p>常用来解决稀疏图。</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>树论</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Floyd</title>
    <link href="/2024/08/04/Floyd/"/>
    <url>/2024/08/04/Floyd/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>你以为这篇最短路和其他最短路差了一天的时间吗？不，实际上只差了一个小时(ノへ￣、)</em></p><p><strong>现在是00: 24</strong></p><p><strong>半夜三更发癫很正常，如有发癫您就别管那点鸡毛小事了hhh</strong></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>用于多源汇最短路问题，也就是有多个源点的最短路问题。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li>邻接矩阵存储所有的边</li><li>直接上三重循环。啊就是找起点终点和跳板点然后通过跳板点更新dis嘛不想解释了看代码吧。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>dis[i][j]=<span class="hljs-built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>你以为它是暴力？哈哈哈其实别人是基于动规的hhh。</p><p>这才是它的本来面貌：<br><code>d[k][i][j]=d[k-1][i][k]+d[k-1][k][j]</code><br>然后大佬把第一维给优化掉了hhh</p><p>所以要先循环k的hhh</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>其实模板上面已经给了，所以这里直接上例题吧。</p><p><a href="https://www.acwing.com/problem/content/856/">AcWing854-Floyd求最短路</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">202</span>;<br><br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> x,y,z;<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                d[i][j]=<span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        d[x][y]=<span class="hljs-built_in">min</span>(d[x][y],z);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)d[i][i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(d[x][y]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>)cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<span class="hljs-comment">//防止原本到不了的元素之间的负边导致终点减少。</span><br>        <span class="hljs-keyword">else</span> cout&lt;&lt;d[x][y];<br>        cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>Floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-SPFA</title>
    <link href="/2024/08/03/SPFA/"/>
    <url>/2024/08/03/SPFA/</url>
    
    <content type="html"><![CDATA[<h1 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h1><p><del>关于SPFA，它亖了</del></p><p>就是对Bellman-Ford算法的一种优化。<del>事实证明优化地很成功，直接给BF差不多干没了</del></p><p>可以得出，节点i路程变化，当且仅当指向i的节点的路程变化，然后就能写出一个接近bfs的算法。</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>通常情况下，SPFA是快于Dijkstra的。</p><p>！！！但是！SPFA它<del>亖了</del>容易被卡啊！被卡了就真亖了！！！</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li>把起点插入队列</li><li>取出队头，更新队头的所有出边。</li><li>每个更新成功的出边，都把另一个节点插入队列。</li><li>重复执行2、3步直到队列为空。</li></ol><p><em>有没有发现长得很像堆优化的Dijkstra？像就对了(^▽^)</em></p><p><strong>注意：不同于Dij，SPFA存储的判断数组是判断元素是否在队列中（可重复访问），而Dij的是判断元素有没有被访问过（不可重复访问）</strong></p><p><strong>同时，因为负环的存在，是不存在“剪枝”操作的~</strong></p><h1 id="判断负环"><a href="#判断负环" class="headerlink" title="判断负环"></a>判断负环</h1><p>顺便记录一下路径经过的点个数，如果个数超过n，就说明有环了。这个环还能被更新，就说明它是个<strong>负环</strong>。</p><p>注意，开始时<strong>所有点都是起点</strong>。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1.5e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y,z;<br><span class="hljs-type">int</span> dis[N];<br><br><span class="hljs-type">int</span> idk;<br><span class="hljs-type">int</span> hd[N],ne[N],to[N],ed[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    ed[++idk]=x;<br>    to[idk]=v;<br>    ne[idk]=hd[u];<br>    hd[u]=idk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> be,<span class="hljs-type">int</span> en)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-type">bool</span> inq[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(be);<br>    dis[be]=<span class="hljs-number">0</span>;<br>    inq[be]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> now=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        inq[now]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//不可以加“剪枝”，因为有负环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[now];i;i=ne[i])&#123;<br>            <span class="hljs-keyword">if</span>(dis[to[i]]&gt;dis[now]+ed[i])&#123;<br>                dis[to[i]]=dis[now]+ed[i];<br>                <span class="hljs-keyword">if</span>(!inq[to[i]])&#123;<br>                    q.<span class="hljs-built_in">push</span>(to[i]);<br>                    inq[to[i]]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[en]==<span class="hljs-number">0x3f3f3f3f</span>)cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dis[en];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-built_in">merge</span>(x,y,z);<br>    &#125;<br>    <span class="hljs-built_in">spfa</span>(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断负环-1"><a href="#判断负环-1" class="headerlink" title="判断负环"></a>判断负环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1.5e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y,z;<br><span class="hljs-type">int</span> dis[N],cnt[N];<br><br><span class="hljs-type">int</span> idk;<br><span class="hljs-type">int</span> hd[N],ne[N],to[N],ed[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    ed[++idk]=x;<br>    to[idk]=v;<br>    ne[idk]=hd[u];<br>    hd[u]=idk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">bool</span> inq[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        cnt[i]=<span class="hljs-number">1</span>;<br>        inq[i]=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> now=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        inq[now]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[now];i;i=ne[i])&#123;<br>            <span class="hljs-keyword">if</span>(dis[to[i]]&gt;dis[now]+ed[i])&#123;<br>                dis[to[i]]=dis[now]+ed[i];<br>                cnt[to[i]]=cnt[now]<span class="hljs-number">+1</span>;<br>                <span class="hljs-keyword">if</span>(cnt[now]&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(!inq[to[i]])&#123;<br>                    q.<span class="hljs-built_in">push</span>(to[i]);<br>                    inq[to[i]]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-built_in">merge</span>(x,y,z);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>())cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>SPFA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Bellman-Ford</title>
    <link href="/2024/08/03/Bellman-Ford/"/>
    <url>/2024/08/03/Bellman-Ford/</url>
    
    <content type="html"><![CDATA[<h1 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h1><p>常用于在有负权边的有向<strong>无环</strong>图中进行最短路判断。</p><p>要是有负权回路就没有结果了（或结果是负无穷）。解释：每转一圈距离就减一点，那我转啊转啊转啊转啊……然后就不出来了(～￣▽￣)～</p><p>事实上用<del>死了的</del>SPFA更好o(<em>￣︶￣</em>)o</p><p><strong>因此，事实上，一般用BELLMAN-FORD的都是有边数长度限制的题目，具体会在世纪意义中说明。</strong></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>重复执行n次：<br>遍历所有边，尝试更新每个边指向点的dis。（松弛操作）</p><p>啊对了每次遍历记得用上一次操作的结果来操作，不然会发生串联（本来要走两步的，但因为先后遍历了相邻两条边，导致一步之内走了两步）<br>。</p><p>。</p><p>对就没了(^▽^)</p><h2 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h2><p>迭代第k次，dis里存的是经过不超过k条边能到达的最短距离。</p><p>因此，可以求有最大边数限制的最短路问题，并且有负环也无所谓。</p><p>同时，它还可以判断是否存在负环：</p><p>若迭代第n次，还有点被更新，说明图中存在一条<strong>长度大于等于n的边</strong>，但一共只有n个点，所以一定有<strong>至少两个点被走了两次</strong>，所以存在环。又因为可以更新，所以这个环是<strong>负环</strong>。</p><p><em>然鹅一般找负环都是用SPFA做hh</em></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>由于负权最短路一般都给SPFA实现去了，这就来一道只能用贝尔曼弗德的题吧。</p><p><a href="https://www.acwing.com/problem/content/855/">AcWing853-有边数限制的最短路</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>,M=<span class="hljs-number">1e4</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> x,y,z;<br>&#125;es[M];<br><br><span class="hljs-type">int</span> n,k,m;<br><span class="hljs-type">int</span> dis[N],lis[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;k;t++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)lis[i]=dis[i];<span class="hljs-comment">//记录上一次的结果防止串联</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            dis[es[i].y]=<span class="hljs-built_in">min</span>(dis[es[i].y],lis[es[i].x]+es[i].z);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[n]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>)cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<span class="hljs-comment">//不能写等于正无穷，因为负权边两侧正无穷能更新对方</span><br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dis[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;es[i].x&gt;&gt;es[i].y&gt;&gt;es[i].z;<br>    &#125;<br>    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>Bellman-Ford</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Dijkstra(HeapOptimized)迪杰斯特拉（堆优化）</title>
    <link href="/2024/08/03/Dijkstra-HeapOptimized/"/>
    <url>/2024/08/03/Dijkstra-HeapOptimized/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>其实就是用堆来优化Dijkstra算法（废话）。由于O(logm)（STL）与O(logn)（手写）为同一数量级，所以还是推荐直接用STL里的优先队列了。</p><p>其实就是优化了找当前距离最短的点的过程嘛。</p><p>由于是稀疏图，所以要用链式前向星做了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>事实上这种优化算法往往比朴素版更常见~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1.5e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y,z;<br><br><span class="hljs-type">int</span> idk;<br><span class="hljs-type">int</span> hd[N],ne[N],to[N],ed[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    ed[++idk]=x;<br>    to[idk]=v;<br>    ne[idk]=hd[u];<br>    hd[u]=idk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> be,<span class="hljs-type">int</span> en)</span></span>&#123;<br>    <span class="hljs-type">int</span> dis[N];<br>    <span class="hljs-type">bool</span> fns[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq;<br>    dis[be]=<span class="hljs-number">0</span>;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,be&#125;);<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">auto</span> tp=pq.<span class="hljs-built_in">top</span>();pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> ds=tp.first,dt=tp.second;<br>        <span class="hljs-keyword">if</span>(fns[dt])<span class="hljs-keyword">continue</span>;<br>        fns[dt]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(dt==en)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[dt];i;i=ne[i])&#123;<br>            <span class="hljs-keyword">if</span>(dis[to[i]]&gt;dis[dt]+ed[i])&#123;<br>                dis[to[i]]=dis[dt]+ed[i];<br>                pq.<span class="hljs-built_in">push</span>(&#123;dis[to[i]],to[i]&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[en]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dis[en]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-built_in">merge</span>(x,y,z);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">dij</span>(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Dijkstra(Plain)迪杰斯特拉（朴素版）</title>
    <link href="/2024/08/03/Dijkstra-Plain/"/>
    <url>/2024/08/03/Dijkstra-Plain/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>与之前不同的是，图论的问题，重实现，而不重原理，所以这几篇博客会重点记录实现部分。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li>初始化：设立一个集合S（空）储存所有已确定最短距离的点，并设立距离dis数组，除了起点设为0外，其他点都设为正无穷。</li><li>在所有点中，找一个不在S里并且dis最小的点t</li><li>把t加入集合S，并且更新所有与之相连的点的距离。</li><li>重复执行2、3步直到每个点都加入集合S</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><em>update 2024&#x2F;8&#x2F;3: 新打了一份代码，在老代码下面，别急着走啊( •̀ ω •́ )✧</em></p><p>本来打算打一份邻接表&#x2F;链式前向星，但只找到了邻接矩阵的代码，反正没差多少，就写了吧。</p><p>注：赶时间，所以只能交一份陈年老代码，马蜂混乱(～￣▽￣)～</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,p,k,a,b,l;<br><span class="hljs-type">int</span> sz[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">1005</span>],vis[<span class="hljs-number">1005</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;p;<br>    <span class="hljs-built_in">memset</span>(sz,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(sz));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;l;<br>        <span class="hljs-keyword">if</span>(sz[a][b]!=<span class="hljs-number">-1</span>)sz[a][b]=<span class="hljs-built_in">min</span>(sz[a][b],l);<br>        <span class="hljs-keyword">else</span> sz[a][b]=l;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)dis[i]=INT_MAX;<br>    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-type">int</span> mn=INT_MAX,mi=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(dis[i]&lt;mn&amp;&amp;!vis[i])&#123;<br>                mn=dis[i];<br>                mi=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!mi)<span class="hljs-keyword">break</span>;<br>        vis[mi]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(sz[mi][i]!=<span class="hljs-number">-1</span>&amp;&amp;dis[mi]+sz[mi][i]&lt;dis[i]&amp;&amp;!vis[i])&#123;<br>                dis[i]=dis[mi]+sz[mi][i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[n]==INT_MAX)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>    cout&lt;&lt;dis[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>新打了一份，照样是邻接矩阵，但是码风好看多了~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> x,y,z;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> be,<span class="hljs-type">int</span> en)</span></span>&#123;<br>    <span class="hljs-type">bool</span> fns[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-type">int</span> dis[N];<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    dis[be]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> mi=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!fns[j]&amp;&amp;(mi==<span class="hljs-number">-1</span>||dis[j]&lt;dis[mi]))mi=j;<br>        &#125;<br>        fns[mi]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(mi==en)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            dis[j]=<span class="hljs-built_in">min</span>(dis[j],dis[mi]+g[mi][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[en]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dis[en];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        g[x][y]=<span class="hljs-built_in">min</span>(g[x][y],z);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">dij</span>(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>Dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Shortest_Circuit_Problem(General)最短路问题总概</title>
    <link href="/2024/08/03/Shortest-Circuit-Problem-General/"/>
    <url>/2024/08/03/Shortest-Circuit-Problem-General/</url>
    
    <content type="html"><![CDATA[<p>#前言<br>本篇博客主要是总概整个最短路问题的算法一览，并不包括每个算法解析，如有需要，请看左边侧边栏的同分类下文章，毕竟也不多，自行寻找，谢谢。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>最短路问题就是求从某点到某点的最短距离。</p><p>源点就是起点，汇点就是终点。</p><h1 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h1><h2 id="边权全为正"><a href="#边权全为正" class="headerlink" title="边权全为正"></a>边权全为正</h2><h3 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h3><p>时间复杂度是O(n<sup>2</sup>)。故多用于稠密图。</p><h3 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h3><p>使用堆优化Dijkstra算法，时间复杂度O(mlogn)。故多用于稀疏图。</p><h2 id="存在负权边"><a href="#存在负权边" class="headerlink" title="存在负权边"></a>存在负权边</h2><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>时间复杂度O(nm)</p><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p><del>关于SPFA，它死了</del></p><p>时间复杂度一般O(m)，最坏O(nm)。</p><h1 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h1><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>时间复杂度O(n<sup>3</sup>)。</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Topo_Sort拓扑排序</title>
    <link href="/2024/08/03/Topo-Sort/"/>
    <url>/2024/08/03/Topo-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>拓扑排序，就是对图中的点进行排序。</p><p>排序方式如下：</p><p>对于每一个点，它指向的点都排在它后面，指向它的点都排在它前面。</p><p>所以，图只能是有向图，还得是<strong>有向无环图</strong>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>记录每一个点的入度，把入度为0的点加入队列，然后BFS一遍，每遍历一个点，就把它“删掉”，使其所有相邻点入度减一，然后再把入度为0的点加入队列。</p><p>无须用到vis数组的证明：如果重复遇到同一个点，则说明指向这个点的边不止一条，但是只有当入度为0时才会把这个点加入队列，所以这个点只会被遍历一次。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>由于这是个算法，所以模板不是很固定，所以就直接上模板题吧。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/850/">AcWing848-有向图的拓扑排序</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-type">int</span> dg[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><br><span class="hljs-type">int</span> idk;<br><span class="hljs-type">int</span> hd[N],to[N],ne[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    to[++idk]=b;<br>    ne[idk]=hd[a];<br>    hd[a]=idk;<br>    dg[b]++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> fns=<span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(dg[i]==<span class="hljs-number">0</span>)q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> now=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        vec.<span class="hljs-built_in">push_back</span>(now);<br>        fns++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[now];i;i=ne[i])&#123;<br>            dg[to[i]]--;<br>            <span class="hljs-keyword">if</span>(dg[to[i]]==<span class="hljs-number">0</span>)q.<span class="hljs-built_in">push</span>(to[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fns==n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-built_in">merge</span>(x,y);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">topo</span>())&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;vec.<span class="hljs-built_in">size</span>();i++)cout&lt;&lt;vec[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Storage_of_Graph图的存储</title>
    <link href="/2024/08/03/Storage-of-Graph/"/>
    <url>/2024/08/03/Storage-of-Graph/</url>
    
    <content type="html"><![CDATA[<h1 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h1><p>啊开个二维数组，然后a[i][j]表示i到j的边长。完事了。</p><h1 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h1><p>利用链表储存每个点的相邻节点。</p><h1 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h1><p>哈希中拉链法头插法也是用的这个。<br><a href="https://githarlem.github.io/2024/08/02/Hash-Table/">[编程笔记]-Hash_Table哈希表</a></p><p>记录每个节点的第一条边、每条边的边长、每条边指向的节点、每条边的下一条边（指把这个节点的所有边形成一种链式结构链接），然后就能遍历所有边了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>前面两个都太简单了，所以就直接上链式前向星的代码吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> x)</span></span>&#123;<br>ed[++idk]=x;<br>to[idk]=v;<br>ne[idk]=hd[u];<br>hd[u]=idk;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>树论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-BFS广度优先搜索</title>
    <link href="/2024/08/03/BFS/"/>
    <url>/2024/08/03/BFS/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>BFS(Breadth First Search)，广度优先搜索，典中典，重中重。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>一般用来在图、树中进行搜索。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>过程可视作一棵树，每次把所有子节点都搜一遍，然后把所有子节点加入待搜索的队列中，排着队一个一个搜，每一个又把所有子节点加入队中……</p><p>其实就是一层一层地搜索~</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>一般用队列来模拟，需要O(2<sup>h</sup>)的空间。同时，由于BFS算法的性质，它可以用来解决“最短路”问题。</p><p><em>实现最短路：第一次搜到的点肯定是离根节点最近的路径搜到的点。</em></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本来不想写的，但是想到DFS那里我就鸽了所以这里不得不写了hh</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> be, <span class="hljs-type">int</span> en)</span></span>&#123;<br><span class="hljs-type">int</span> d[N];queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(d));<br>d[be]=<span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(d);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-comment">//取出点</span><br><span class="hljs-comment">//找相邻点</span><br><span class="hljs-comment">//如果是终点就直接退出了。</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为啥不打完呢……因为BFS的写法很多样，不唯一，所以给个思路就行了。</p><p>（归根结底就是这个蒟蒻太懒了hhh）</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>就来一道毒瘤吧</p><p><a href="https://www.acwing.com/problem/content/847/">AcWing845-八数码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> a;<br>string str=<span class="hljs-string">&quot;&quot;</span>;<br>string en=<span class="hljs-string">&quot;12345678x&quot;</span>;<br><br>unordered_map&lt;string,<span class="hljs-type">int</span>&gt; d;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string be)</span></span>&#123;<br>    queue&lt;string&gt; q;<br>    q.<span class="hljs-built_in">push</span>(be);<br>    d[be]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        string now=q.<span class="hljs-built_in">front</span>(),tstr;q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(now==en)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> t=now.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;x&#x27;</span>);<br>        <span class="hljs-type">int</span> tx=t/<span class="hljs-number">3</span>,ty=t%<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nx=tx+dx[i],ny=ty+dy[i];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;=nx&amp;&amp;nx&lt;<span class="hljs-number">3</span>&amp;&amp;<span class="hljs-number">0</span>&lt;=ny&amp;&amp;ny&lt;<span class="hljs-number">3</span>)&#123;<br>                tstr=now;<br>                <span class="hljs-built_in">swap</span>(tstr[t],tstr[nx*<span class="hljs-number">3</span>+ny]);<br>                <span class="hljs-keyword">if</span>(!d.<span class="hljs-built_in">count</span>(tstr))&#123;<br>                    d[tstr]=d[now]<span class="hljs-number">+1</span>;<br>                    q.<span class="hljs-built_in">push</span>(tstr);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>        cin&gt;&gt;a;<br>        str+=a;<br>    &#125;<br>    <span class="hljs-built_in">bfs</span>(str);<br>    <span class="hljs-keyword">if</span>(!d.<span class="hljs-built_in">count</span>(en))cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;d[en];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>树论</tag>
      
      <tag>BFS</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-DFS深度优先搜索</title>
    <link href="/2024/08/03/DFS/"/>
    <url>/2024/08/03/DFS/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>DFS(Deep First Search)，深度优先搜索，典中典，重中重。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>一般用来在图、树中进行搜索。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>过程可视作一棵树，每次向着子节点搜索，搜到叶节点就回溯，然后搜下一个子节点，直到把子节点搜完了就接着回溯。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>一般用栈来模拟，需要O(h)的空间</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>就是从子节点回到父节点</p><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>跳过已经遍历过的点减少时间复杂度。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>这个太简单了，过(～￣▽￣)～</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>这个嘛……说句实话不是很常用，而且和BFS的代码基本没有区别，所以就不写了。</p><p>挂个BFS，需要者自取：</p><p><a href="https://githarlem.github.io/2024/08/03/BFS/">[编程笔记]-BFS广度优先搜索</a></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>这么典的算法，肯定要配一个超典的题型~</p><p><strong>n皇后问题</strong></p><p><a href="https://www.acwing.com/problem/content/submission/845/">AcWing843-n皇后问题</a></p><h2 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h2><p><em>为啥先讲进阶版？您是先学会用打火机还是先学会钻木取火？</em></p><p>由于每一行都只有一个皇后，所以遍历每一行就行了，整体思路根全排列一样。</p><p>给每个竖列、对角线都设立一个对应判断值，然后直接套板子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> use[N];<br><span class="hljs-type">bool</span> vis[N]=&#123;<span class="hljs-literal">false</span>&#125;,deg[N*<span class="hljs-number">2</span>]=&#123;<span class="hljs-literal">false</span>&#125;,fdg[N*<span class="hljs-number">2</span>]=&#123;<span class="hljs-literal">false</span>&#125;;<span class="hljs-comment">//deg-&gt;右倾对角线右侧顶点；fdg-&gt;左倾对角线右侧顶点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(now==n<span class="hljs-number">+1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(use[i]==j)cout&lt;&lt;<span class="hljs-string">&#x27;Q&#x27;</span>;<br>                <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>            cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;!deg[n-now+i]&amp;&amp;!fdg[now+i])&#123;<br>            use[now]=i;<br>            vis[i]=deg[n-now+i]=fdg[now+i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(now<span class="hljs-number">+1</span>);<br>            vis[i]=deg[n-now+i]=fdg[now+i]=<span class="hljs-literal">false</span>;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h2><p>暴力循环每一个格子——选or不选……选or不选……</p><p>然后每n<sup>2</sup>次对一下答案。</p><p>听起来就暴力极了。(^▽^)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//反正判断行列跟进阶版一样，然后思路又简单到爆炸，所以想必就不用我这个蒟蒻打了(^▽^)</span><br></code></pre></td></tr></table></figure><h1 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h1><p>毕竟是图论问题，还是来一道和图论关系大的吧。<br><a href="https://www.acwing.com/problem/content/848/">AcWing846-树的重心</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> idk;<br><span class="hljs-type">int</span> ed[N*<span class="hljs-number">2</span>],to[N*<span class="hljs-number">2</span>],ne[N*<span class="hljs-number">2</span>],hd[N];<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a,b;<br><span class="hljs-type">int</span> vis[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> v=<span class="hljs-number">1</span>)</span></span>&#123;<br>    ed[++idk]=v;<br>    to[idk]=y;<br>    ne[idk]=hd[x];<br>    hd[x]=idk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfsize</span><span class="hljs-params">(<span class="hljs-type">int</span> now)</span></span>&#123;<br>    vis[now]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,sum=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[now];i;i=ne[i])&#123;<br>        <span class="hljs-keyword">if</span>(!vis[to[i]])&#123;<br>            <span class="hljs-type">int</span> t=<span class="hljs-built_in">dfsize</span>(to[i]);<br>            res=<span class="hljs-built_in">max</span>(res,t);<br>            sum+=t;<br>        &#125;<br>    &#125;<br>    res=<span class="hljs-built_in">max</span>(res,n-sum);<br>    ans=<span class="hljs-built_in">min</span>(ans,res);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">merge</span>(a,b);<br>        <span class="hljs-built_in">merge</span>(b,a);<br>    &#125;<br>    <span class="hljs-built_in">dfsize</span>(n);<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>树论</tag>
      
      <tag>搜索</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-STLs(STL大整合)</title>
    <link href="/2024/08/03/STLs/"/>
    <url>/2024/08/03/STLs/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>手打STL毕竟只是锦上添花，STL才是雪中送炭。</p><p>所以，来一篇STL<del>大杂烩</del>大整合！</p><p>注意，这里只整理了常用函数，并不是全部函数！</p><h1 id="VECTOR"><a href="#VECTOR" class="headerlink" title="VECTOR"></a>VECTOR</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>是一种动态数组，运用到倍增的思想。</p><p>按字典序排序。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><em>因为申请空间耗时与空间大小无关、与申请次数有关——</em></p><p>所以vector会倍增申请空间o(<em>￣︶￣</em>)o</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>push_back()</code></td><td align="center">在队尾加入元素</td><td align="left"><code>vec.push_back(加入元素)</code></td></tr><tr><td align="center"><code>pop_back()</code></td><td align="center">在队尾删除元素</td><td align="left"><code>vec.pop_back()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">判断是否为空</td><td align="left"><code>vec.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>vec.clear()</code></td></tr><tr><td align="center"><code>size()</code></td><td align="center">元素个数</td><td align="left"><code>vec.size()</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查找元素位置，否则返回队尾</td><td align="left"><code>find(起始位置, 终止位置, 查找元素)</code></td></tr><tr><td align="center"><code>front()</code></td><td align="center">返回队头元素</td><td align="left"><code>vec.front()</code></td></tr><tr><td align="center"><code>back()</code></td><td align="center">返回队尾元素</td><td align="left"><code>vec.back()</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回队头迭代器</td><td align="left"><code>vec.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回队尾迭代器（最后元素的后一个元素）</td><td align="left"><code>vec.end()</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除指定元素</td><td align="left"><code>vec.erase(迭代器)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除指定区间（左闭右开）元素</td><td align="left"><code>vec.erase(开始迭代器, 结束迭代器)</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center">随机选址</td><td align="left"><code>vec[]</code></td></tr></tbody></table><h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><ul><li><code>vector&lt;TYPE&gt; a</code>，定义一个存储TYPE类型变量vector a。</li><li><code>vector&lt;TYPE&gt; a(n)</code>，定义一个大小为n的存储TYPE类型变量vector a。</li><li><code>vector&lt;TYPE&gt; a(n, x)</code>，定义一个大小为n的存储TYPE类型变量且初始值全为x的vector a。</li><li><code>vector&lt;TYPE&gt; a[n]</code>，定义n个存储TYPE类型变量vector a。</li></ul><h1 id="PAIR"><a href="#PAIR" class="headerlink" title="PAIR"></a>PAIR</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>两个元素（不限种类）的结合体。</p><p>有点就是自带比较函数，先比第一个再比第二个（各自按字典序排序），可以很方便地<code>sort()</code>。</p><h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>first</code></td><td align="center">第一元素</td><td align="left"><code>p.first</code></td></tr><tr><td align="center"><code>second</code></td><td align="center">第二元素</td><td align="left"><code>p.second</code></td></tr></tbody></table><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p><code>pair&lt;T1, T2&gt; p</code>，定义一个两个元素分别是T1类型和T2类型的pair p。</p><ul><li>make_pair(a, b)，返回一个由a和b构成的pair。</li><li>{a, b}，返回一个由a和b构成的pair。（c++11专用）</li></ul><h1 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>字符串。</p><h2 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>substr()</code></td><td align="center">截取子串</td><td align="left"><code>str.substr(起始下标, 截取长度)</code></td></tr><tr><td align="center"><code>c_str()</code></td><td align="center">转换为c语言字符串（支持scanf）</td><td align="left"><code>str.c_str()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">判断是否为空</td><td align="left"><code>str.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>str.clear()</code></td></tr><tr><td align="center"><code>size()</code></td><td align="center">字符串长度</td><td align="left"><code>str.size()</code></td></tr><tr><td align="center"><code>length()</code></td><td align="center">字符串长度</td><td align="left"><code>str.length()</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查询字符位置</td><td align="left"><code>str.find(查询字符)</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center">随机选址</td><td align="left"><code>str[]</code></td></tr></tbody></table><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h4><p>如果截取长度超出字符串长度，或没有设定截取长度，默认截取至结尾。</p><h4 id="c-str"><a href="#c-str" class="headerlink" title="c_str()"></a>c_str()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a.<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><code>string a</code>，定义一个string a。</li><li><code>string a = str</code>，定义一个内容为str的string a。</li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li>a+&#x3D;b，在a末尾加上b（string）。</li><li>a+&#x3D;b，在a末尾加上b（char）。</li></ul><h1 id="QUEUE"><a href="#QUEUE" class="headerlink" title="QUEUE"></a>QUEUE</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>队列。</p><h2 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>push()</code></td><td align="center">入队</td><td align="left"><code>q.push(入队元素)</code></td></tr><tr><td align="center"><code>pop()</code></td><td align="center">队头出队</td><td align="left"><code>q.pop()</code></td></tr><tr><td align="center"><code>front()</code></td><td align="center">获取队头</td><td align="left"><code>q.front()</code></td></tr><tr><td align="center"><code>back()</code></td><td align="center">获取队尾</td><td align="left"><code>q.back()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">判断是否为空</td><td align="left"><code>q.empty()</code></td></tr><tr><td align="center"><code>size()</code></td><td align="center">队列元素个数</td><td align="left"><code>q.size()</code></td></tr></tbody></table><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><p>直接重开一个队列就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">q=<span class="hljs-built_in">queue</span>&lt;TYPE&gt;();<br></code></pre></td></tr></table></figure><h1 id="PRIORITY-QUEUE"><a href="#PRIORITY-QUEUE" class="headerlink" title="PRIORITY_QUEUE"></a>PRIORITY_QUEUE</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>优先队列（堆），默认大根堆</p><p><strong>比较常用</strong></p><h2 id="常用函数-4"><a href="#常用函数-4" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>push()</code></td><td align="center">入堆</td><td align="left"><code>pq.push(入堆元素)</code></td></tr><tr><td align="center"><code>top()</code></td><td align="center">获取堆顶</td><td align="left"><code>pq.top()</code></td></tr><tr><td align="center"><code>pop()</code></td><td align="center">堆顶出堆</td><td align="left"><code>pq.pop()</code></td></tr></tbody></table><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><h3 id="实现小根堆"><a href="#实现小根堆" class="headerlink" title="实现小根堆"></a>实现小根堆</h3><ul><li>插入-x，最后输出的时候取反。</li><li><code>priority_queue&lt;TYPE, vector&lt;TYPE&gt;, greater&lt;TYPE&gt; &gt;</code></li></ul><h1 id="STACK"><a href="#STACK" class="headerlink" title="STACK"></a>STACK</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><p>栈</p><h2 id="常用函数-5"><a href="#常用函数-5" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>push()</code></td><td align="center">入栈</td><td align="left"><code>st.push(入栈元素)</code></td></tr><tr><td align="center"><code>top()</code></td><td align="center">获取栈顶</td><td align="left"><code>st.top()</code></td></tr><tr><td align="center"><code>pop()</code></td><td align="center">栈顶出栈</td><td align="left"><code>st.pop()</code></td></tr><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>st.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>st.empty()</code></td></tr></tbody></table><h1 id="DEQUE"><a href="#DEQUE" class="headerlink" title="DEQUE"></a>DEQUE</h1><h2 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h2><p>双端队列</p><p><del>很牛逼哒</del></p><p><em>效率低的令人发指，慢了好几倍~</em></p><h2 id="常用函数-6"><a href="#常用函数-6" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>dq.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>dq.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>dq.clear()</code></td></tr><tr><td align="center"><code>front()</code></td><td align="center">获取队头</td><td align="left"><code>dq.front()</code></td></tr><tr><td align="center"><code>back()</code></td><td align="center">获取队尾</td><td align="left"><code>dq.back()</code></td></tr><tr><td align="center"><code>push_front()</code></td><td align="center">在队头加入元素</td><td align="left"><code>dq.push_front(加入元素)</code></td></tr><tr><td align="center"><code>pop_front()</code></td><td align="center">在队头删除元素</td><td align="left"><code>dq.pop_front()</code></td></tr><tr><td align="center"><code>push_back()</code></td><td align="center">在队尾加入元素</td><td align="left"><code>dq.push_back(加入元素)</code></td></tr><tr><td align="center"><code>pop_back()</code></td><td align="center">在队尾删除元素</td><td align="left"><code>dq.pop_back()</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center">随机选址</td><td align="left"><code>dq[]</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回队头迭代器</td><td align="left"><code>dq.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回队尾迭代器（最后元素的后一个元素）</td><td align="left"><code>dq.end()</code></td></tr></tbody></table><h1 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h1><h2 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>基于平衡二叉树（红黑树），动态维护有序序列。</p><p><code>set</code>不能有重复元素，否则会被忽略掉。<br>而<code>multiset</code>可以。</p><h3 id="常用函数-7"><a href="#常用函数-7" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>s.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>s.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>s.clear()</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回第一个迭代器</td><td align="left"><code>s.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回最后的迭代器（最后元素的后一个元素）</td><td align="left"><code>s.end()</code></td></tr><tr><td align="center"><code>insert()</code></td><td align="center">插入元素</td><td align="left"><code>s.insert(插入元素)</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查找元素，若无则返回end迭代器</td><td align="left"><code>s.find(查找元素)</code></td></tr><tr><td align="center"><code>count()</code></td><td align="center">返回某一元素个数</td><td align="left"><code>s.count(查找元素)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除所有对应值的元素</td><td align="left"><code>s.erase(删除值)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应迭代器的元素</td><td align="left"><code>s.erase(删除迭代器)</code></td></tr><tr><td align="center"><code>lower_bound()</code></td><td align="center">返回大于等于标准值的最小数迭代器</td><td align="left"><code>s.lower_bound(标准值)</code></td></tr><tr><td align="center"><code>upper_bound()</code></td><td align="center">返回大于标准值的最小数迭代器</td><td align="left"><code>s.upper_bound(标准值)</code></td></tr></tbody></table><h3 id="定义方式-1"><a href="#定义方式-1" class="headerlink" title="定义方式"></a>定义方式</h3><p><code>set&lt;TYPE&gt; s</code>，定义一个存储TYPE类型变量set s。<br><code>multiset&lt;TYPE&gt; ms</code>，定义一个存储TYPE类型变量multiset ms。</p><h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h3><p>迭代器可以++&#x2F;–，前移后移。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>绝大部分O(logn)</p><h2 id="unordered-set-unordered-muiltiset"><a href="#unordered-set-unordered-muiltiset" class="headerlink" title="unordered_set&#x2F;unordered_muiltiset"></a>unordered_set&#x2F;unordered_muiltiset</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>基于哈希表实现</p><h3 id="常用函数-8"><a href="#常用函数-8" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>us.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>us.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>us.clear()</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回第一个迭代器</td><td align="left"><code>us.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回最后的迭代器（最后元素的后一个元素）</td><td align="left"><code>us.end()</code></td></tr><tr><td align="center"><code>insert()</code></td><td align="center">插入元素</td><td align="left"><code>us.insert(插入元素)</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查找元素，若无则返回end迭代器</td><td align="left"><code>us.find(查找元素)</code></td></tr><tr><td align="center"><code>count()</code></td><td align="center">返回某一元素个数</td><td align="left"><code>us.count(查找元素)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除所有对应值的元素</td><td align="left"><code>us.erase(删除值)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应迭代器的元素</td><td align="left"><code>us.erase(删除迭代器)</code></td></tr></tbody></table><h3 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h3><p>迭代器<strong>不</strong>可以++&#x2F;–，前移后移。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>增删改查O(1)</p><h1 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h1><h2 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>基于平衡二叉树（红黑树），动态维护有序序列。</p><h3 id="常用函数-9"><a href="#常用函数-9" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>m.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>m.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>m.clear()</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回第一个迭代器</td><td align="left"><code>m.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回最后的迭代器（最后元素的后一个元素）</td><td align="left"><code>m.end()</code></td></tr><tr><td align="center"><code>insert()</code></td><td align="center">插入一对元素</td><td align="left"><code>m.insert(插入pair)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应对元素</td><td align="left"><code>m.erase(删除pair)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应迭代器元素</td><td align="left"><code>m.erase(删除迭代器)</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查找要求键元素迭代器，若无则返回end迭代器</td><td align="left"><code>m.find(要求查找键)</code></td></tr><tr><td align="center"><code>count()</code></td><td align="center">返回某一元素个数</td><td align="left"><code>m.count(查找元素)</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center">像使用数组一样使用（查找、修改）</td><td align="left"><code>m[]</code></td></tr><tr><td align="center"><code>lower_bound()</code></td><td align="center">返回大于等于标准值的最小数迭代器</td><td align="left"><code>m.lower_bound(标准值)</code></td></tr><tr><td align="center"><code>upper_bound()</code></td><td align="center">返回大于标准值的最小数迭代器</td><td align="left"><code>m.upper_bound(标准值)</code></td></tr></tbody></table><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>[]</code>的时间复杂度是O(logn)的。</p><h3 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a>操作</h3><p>迭代器可以++&#x2F;–，前移后移。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>绝大部分O(logn)</p><h2 id="unordered-map-unordered-multimap"><a href="#unordered-map-unordered-multimap" class="headerlink" title="unordered_map&#x2F;unordered_multimap"></a>unordered_map&#x2F;unordered_multimap</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>基于哈希表实现</p><h3 id="常用函数-10"><a href="#常用函数-10" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>um.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>um.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>um.clear()</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回第一个迭代器</td><td align="left"><code>um.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回最后的迭代器（最后元素的后一个元素）</td><td align="left"><code>um.end()</code></td></tr><tr><td align="center"><code>insert()</code></td><td align="center">插入一对元素</td><td align="left"><code>um.insert(插入pair)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应对元素</td><td align="left"><code>um.erase(删除pair)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应迭代器元素</td><td align="left"><code>m.erase(删除迭代器)</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查找要求键元素迭代器，若无则返回end迭代器</td><td align="left"><code>um.find(要求查找键)</code></td></tr><tr><td align="center"><code>count()</code></td><td align="center">返回某一元素个数</td><td align="left"><code>um.count(查找元素)</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center">像使用数组一样使用（查找、修改）</td><td align="left"><code>um[]</code></td></tr></tbody></table><h3 id="操作-6"><a href="#操作-6" class="headerlink" title="操作"></a>操作</h3><p>迭代器<strong>不</strong>可以++&#x2F;–，前移后移。</p><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>增删改查O(1)</p><h1 id="BITSET"><a href="#BITSET" class="headerlink" title="BITSET"></a>BITSET</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>压位</p><p>bool数组一个元素占8位，而bitset一个元素只占1位，节省了八倍内存。</p><h2 id="定义方式-2"><a href="#定义方式-2" class="headerlink" title="定义方式"></a>定义方式</h2><p><code>bitset&lt;n&gt; bs</code>，定义一个存储n个bool的bitset bs。</p><h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>count()</code></td><td align="center">获取1的个数</td><td align="left"><code>bs.count()</code></td></tr><tr><td align="center"><code>any()</code></td><td align="center">判断是否有1</td><td align="left"><code>bs.any()</code></td></tr><tr><td align="center"><code>none()</code></td><td align="center">判断是否全是0</td><td align="left"><code>bs.none()</code></td></tr><tr><td align="center"><code>set()</code></td><td align="center">把所有位设成1</td><td align="left"><code>bs.set()</code></td></tr><tr><td align="center"><code>set()</code></td><td align="center">把要求位置设成要求值</td><td align="left"><code>bs.set(要求位置, 要求值)</code></td></tr><tr><td align="center"><code>reset()</code></td><td align="center">把所有位设成0</td><td align="left"><code>bs.reset()</code></td></tr><tr><td align="center"><code>flip()</code></td><td align="center">把所有位取反</td><td align="left"><code>bs.flip()</code></td></tr><tr><td align="center"><code>flip()</code></td><td align="center">把指定位取反</td><td align="left"><code>bs.flip(指定位)</code></td></tr></tbody></table><h2 id="操作-7"><a href="#操作-7" class="headerlink" title="操作"></a>操作</h2><p>支持所有位运算：<code>&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;</code></p><p>支持<code>==</code>和<code>!=</code></p><p>支持<code>[]</code>看某一位</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-String_Hash字符串哈希</title>
    <link href="/2024/08/03/String-Hash/"/>
    <url>/2024/08/03/String-Hash/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这边首先推荐有需要滴去先瞅眼哈希表。<br><a href="https://githarlem.github.io/2024/08/02/Hash-Table/">“[编程笔记]-Hash_Table哈希表”</a></p><p>（半夜写的，可能有点癫嘿嘿嘿）</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>字符串哈希，就是对字符串进行哈希，达到快速储存和查询的目的。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="求HASH"><a href="#求HASH" class="headerlink" title="求HASH"></a>求HASH</h2><p>这里要用到一种特殊的哈希方法：将字符串视作一个p进制数（p不一定，按题目要求来，一般就是所有可能出现的字符的个数，反正能让每个字符串独一无二就行），然后再对这个p进制数进行哈希操作。别的就一模一样了。</p><p><strong>WARNING: 一般情况下不要映射成0！否则会造成哈希冲突！</strong></p><p><strong>WARNING: <del>这个算法下我们强的可怕！</del>我们rp很nb！不考虑哈希冲突！</strong></p><p><strong>JINGYAN!!!: 当p取131或13331时，q（模）取2<sup>64</sup>时，在99.99%的情况下，都不会出现冲突。</strong></p><p><strong>生活小寄巧：可用<code>ull</code>储存所有哈希值，这样就不用取模了，溢出就相当于取模了哈哈哈。</strong></p><p><strong>所以就易如反掌瓮中捉鳖轻轻松松探囊取物——<code>h[i]=h[i-1]*p+str[i]</code></strong></p><hr><p>另外，这个方法有个<strong>小点</strong>可以注意一下：</p><p>如果我们求出了字符串每个前缀的hash值，就可以求出每个子串的hash值。</p><p>挂一个前缀和吧，<del>虽然应该没有人会需要它</del><a href="https://githarlem.github.io/2024/07/30/Partial-Sum/">“[编程笔记]-Partial_Sum前缀和”</a></p><p>公式：<code>h[r]-h[l]*p^(r-l+1)</code></p><p>推导：举个例子，一个是”GRAY”，一个是”GRAYGOO”，要想得到”GOO”，肯定要用”GRAYGOO”减去”GRAY”左移三位得到的”GRAY   “。<em>当然我更希望去个GOO留GRAY，但为了方便理解还是放弃了。</em></p><p>啊对了其实这个小点是一个重点但是我懒得改前面的内容了所以就在前面加个着重符号吧(╹ڡ╹ )</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>由于这算法本来是用来字符串匹配，但例题拿来子串匹配，不仅完美结合了原方法，还巧妙融合了前缀和问题（就是上面那个重点），所以就直接用这道<del>毒瘤</del>好题了。</p><p><a href="https://www.acwing.com/problem/content/843/">AcWing841-字符串哈希</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>,P=<span class="hljs-number">131</span>;<br><br><span class="hljs-type">int</span> n,m;<br>string str;<br>ull h[N],p[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;str;<br>    str=<span class="hljs-string">&#x27; &#x27;</span>+str;<br>    p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        p[i]=p[i<span class="hljs-number">-1</span>]*P;<br>        h[i]=h[i<span class="hljs-number">-1</span>]*P+str[i];<br>    &#125;<br>    <span class="hljs-type">int</span> l1,r1,l2,r2;<br>    ull h1,h2;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;<br>        h1=h[r1]-h[l1<span class="hljs-number">-1</span>]*p[r1-l1<span class="hljs-number">+1</span>];<br>        h2=h[r2]-h[l2<span class="hljs-number">-1</span>]*p[r2-l2<span class="hljs-number">+1</span>];<br>        cout&lt;&lt;(h1==h2?<span class="hljs-string">&quot;Yes\n&quot;</span>:<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1><p><em>再这么熬下去我就成国家一级保护废物了</em></p>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>哈希</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Hash_Table哈希表</title>
    <link href="/2024/08/02/Hash-Table/"/>
    <url>/2024/08/02/Hash-Table/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>通过哈希函数（自定义，一般是取模），把数据映射到哈希表上。</p><p>听不懂就对了，听得懂也没必要看原理了(～￣▽￣)～</p><p>当然，如果已经学过离散化的，理解起来可能方便些。</p><p>为了方便学习，这里挂一个离散化链接：<br><a href="https://githarlem.github.io/2024/07/31/Discretization/">“[编程笔记]-Discretization离散化”</a></p><p>顺便也挂一个字符串哈希吧，毕竟同根同源~<br><a href="https://githarlem.github.io/2024/08/03/String-Hash/">“[编程笔记]-String_Hash字符串哈希”</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>这点就讲讲哈希函数，为了减少哈希冲突，我们一般都会选择模一个质数。</p><h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><p>有两种方式：拉链法（或者挂链法之类的）和开放寻址法。</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>就是在哈希表上每一个节点后都拉一条链表，遇到冲突的直接插到链表后面，或者用类似链式前向星的方法插到表头。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>遇到冲突想办法找别的空位子坐下。经验表明，一般要开题目要求范围内的两到三倍。</p><p>需要注意的是，开放寻址法中，因为查询也是照着插入的方式一个一个找的，所以如果真的删除了元素的话，那么就会使查找过程异常，所以一般都是打个标记。（删除过程和查询过程一模一样hh）</p><p><em>y总の奇妙比喻belike: 就像澈硕找坑位一样，这个有人，欸<del>下一个，找到空的，欸</del>就你了！</em></p><h2 id="寻找"><a href="#寻找" class="headerlink" title="寻找"></a>寻找</h2><p>靠哈希函数找出当前值应该在的位置，然后挂链法就顺着链表找一遍，开放寻址法麻烦一点，一般暴力做法就是绕着找一圈。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="拉链法-1"><a href="#拉链法-1" class="headerlink" title="拉链法"></a>拉链法</h2><p>鉴于尾插法过于简单，这里使用头插法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> hd[N],ne[N],vl[N],idk;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>                hd[i]=<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> (x%N+N)%N;<span class="hljs-comment">//防负数</span><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            vl[++idk]=x;<br>            <span class="hljs-type">int</span> key=<span class="hljs-built_in">hash</span>(x);<br>            ne[idk]=hd[key];<br>            hd[key]=idk;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-type">int</span> key=<span class="hljs-built_in">hash</span>(x);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[key];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>                <span class="hljs-keyword">if</span>(vl[i]==x)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;hs;<br></code></pre></td></tr></table></figure><h2 id="开放寻址法-1"><a href="#开放寻址法-1" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>本模板中无删除功能，如有需要请自行添加，因为和查找功能基本上没有区别，只需要再单开一个判断是否删除的数组就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> h[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(h));<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> (x%N+N)%N;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">hash</span>(x);<br>            <span class="hljs-keyword">while</span>(h[k]!=nb&amp;&amp;h[k]!=x)&#123;<br>                <span class="hljs-keyword">if</span>(++k==N)k=<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> k;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">find</span>(x);<br>            h[k]=x;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">find</span>(x);<br>            <span class="hljs-keyword">return</span> h[k]==x;<br>        &#125;<br>&#125;hs;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Heap堆</title>
    <link href="/2024/08/02/Heap/"/>
    <url>/2024/08/02/Heap/</url>
    
    <content type="html"><![CDATA[<h1 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h1><p>事实上，堆就是一棵完全二叉树。</p><p>在堆中，以小根堆为例，每个父节点总是小于等于子节点的。</p><p>所以根节点事实上就是最小值。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ol><li>插入一个数</li><li>求集合当中的最小值</li><li>删除最小值</li><li>删除任意元素（STL做不到）</li><li>修改任意元素（STL做不到）</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>利用一维数组实现，2<em>x是x左子节点，2</em>x+1是x右子节点。</p><h2 id="基操"><a href="#基操" class="headerlink" title="基操"></a>基操</h2><p>根有两个基本操作：上移和下移，就是把节点与父节点&#x2F;子节点互换以维护堆的单调性。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>先随便把元素存进去，然后对前n&#x2F;2个元素从后往前进行下移操作，就能完成初始化操作。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(n)。但这个证明有点复杂，就不在这里放出了。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>随便新建一个叶节点，然后执行上移操作。</p><h2 id="求最小值"><a href="#求最小值" class="headerlink" title="求最小值"></a>求最小值</h2><p>根节点啊。</p><h2 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h2><p>将根节点和最后一个节点互换一下，然后直接删掉尾节点（原根节点），最后下移操作维护。</p><p><em>y总的奇妙比喻：现在有一队人，直接杀队头肯定不方便，那么把队头队尾狸猫换太子，直接K掉队尾，神不知鬼不觉，最后维持下秩序就OK了Σ(っ °Д °;)っ</em></p><h2 id="删除任意元素"><a href="#删除任意元素" class="headerlink" title="删除任意元素"></a>删除任意元素</h2><p>和删除最小值一样，不过最后上移下移都要试一遍。</p><h2 id="修改任意元素"><a href="#修改任意元素" class="headerlink" title="修改任意元素"></a>修改任意元素</h2><p>同理，修改指定元素后，上移一遍<del>下移一遍</del>欸，好了（￣︶￣）</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>啊这个堆排序的话只需要获取最小值&amp;输出最小值就OK了，所以其实只会用到下移操作，所以<del>您也跟我一样够懒的话</del>只写下移函数就可以了。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>毕竟是树嘛，所以很快得出是O(logn)啦。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h2><p>还是给一道板子题吧：<br><a href="https://www.acwing.com/problem/content/840/">AcWing838-堆排序</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> now)</span></span>&#123;<br>    <span class="hljs-type">int</span> son=now;<br>    <span class="hljs-keyword">if</span>(now*<span class="hljs-number">2</span>&lt;=n&amp;&amp;a[now*<span class="hljs-number">2</span>]&lt;=a[son])son=now*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(now*<span class="hljs-number">2</span><span class="hljs-number">+1</span>&lt;=n&amp;&amp;a[now*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]&lt;=a[son])son=now*<span class="hljs-number">2</span><span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">if</span>(now!=son)&#123;<br>        <span class="hljs-built_in">swap</span>(a[now],a[son]);<br>        <span class="hljs-built_in">down</span>(son);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        <span class="hljs-built_in">down</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">heap_sort</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cout&lt;&lt;a[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">swap</span>(a[<span class="hljs-number">1</span>],a[n--]);<br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h2><p>注意，这个堆中还记录了插入结点的编号，所以在细节上硬控我半小时(ノへ￣、)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">heap</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> idk,n;<br>        <span class="hljs-type">int</span> h[N],ph[N],hp[N];<span class="hljs-comment">//ph是编号对应的下标，hp是下标对应的编号。</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            <span class="hljs-built_in">swap</span>(h[a],h[b]);<br>            <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>            <span class="hljs-built_in">swap</span>(hp[a],hp[b]);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(h[x/<span class="hljs-number">2</span>]&lt;=h[x])<span class="hljs-keyword">break</span>;<br>                <span class="hljs-built_in">heap_swap</span>(x/<span class="hljs-number">2</span>,x);<br>                x/=<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>                <span class="hljs-type">int</span> t=x;<br>                <span class="hljs-keyword">if</span>(x*<span class="hljs-number">2</span>&lt;=n&amp;&amp;h[x*<span class="hljs-number">2</span>]&lt;h[t])t=x*<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(x*<span class="hljs-number">2</span><span class="hljs-number">+1</span>&lt;=n&amp;&amp;h[x*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]&lt;h[t])t=x*<span class="hljs-number">2</span><span class="hljs-number">+1</span>;<br>                <span class="hljs-keyword">if</span>(t==x)<span class="hljs-keyword">break</span>;<br>                <span class="hljs-built_in">heap_swap</span>(x,t);<br>                x=t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            h[++n]=x;<br>            ph[++idk]=n;<br>            hp[n]=idk;<br>            <span class="hljs-built_in">up</span>(n);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> h[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delmin</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-built_in">heap_swap</span>(<span class="hljs-number">1</span>,n--);<br>            <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delid</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>            <span class="hljs-type">int</span> ok=ph[k];<br>            <span class="hljs-built_in">heap_swap</span>(ph[k],n--);<br>            <span class="hljs-built_in">down</span>(ok);<br>            <span class="hljs-built_in">up</span>(ok);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeid</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<br>            h[ph[k]]=x;<br>            <span class="hljs-built_in">down</span>(ph[k]);<br>            <span class="hljs-built_in">up</span>(ph[k]);<br>        &#125;<br>&#125;hp;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>树论</tag>
      
      <tag>堆</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Union_Find_Set并查集</title>
    <link href="/2024/08/02/Union-Find-Set/"/>
    <url>/2024/08/02/Union-Find-Set/</url>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>以接近O(1)的复杂度合并集合并查询两个元素是否在同一个集合中的简介好用数据结构。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>将每个集合视作一棵树，每个节点储存它的父节点。特别地，根节点储存它本身。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>将每个点的父节点都设为它本身。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>将其中一个集合的根节点的父节点设为另一个集合的根节点。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>看两个点在不在同一个集合中，也就是看两个点的根节点一样不一样。</p><h2 id="优化（路径压缩）"><a href="#优化（路径压缩）" class="headerlink" title="优化（路径压缩）"></a>优化（路径压缩）</h2><p>其实还可以按秩合并，但那个优化代码量相对较大，并且基本上没有毛用，所以就不讲了。</p><p>路径压缩，就是在查询根节点的过程中，把当前节点的父节点直接设为祖先节点，以大大减少合并、查询的时间复杂度。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h2><p>只有最基础的初始化、查询、合并功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Union_Find_Set</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> n,p[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            n=x;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>                p[i]=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(p[x]!=x)p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>            <span class="hljs-keyword">return</span> p[x];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            a=<span class="hljs-built_in">find</span>(a);b=<span class="hljs-built_in">find</span>(b);<br>            p[a]=b;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b);<br>        &#125;<br>&#125;ufs;<br></code></pre></td></tr></table></figure><h2 id="计数版"><a href="#计数版" class="headerlink" title="计数版"></a>计数版</h2><p>可以记录每个集合内的元素个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Union_Find_Set</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> n,p[N],siz[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            n=x;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>                p[i]=i;<br>                siz[i]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(p[x]!=x)p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>            <span class="hljs-keyword">return</span> p[x];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            a=<span class="hljs-built_in">find</span>(a);b=<span class="hljs-built_in">find</span>(b);<br>            <span class="hljs-keyword">if</span>(a!=b)siz[b]+=siz[a];<br>            p[a]=b;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];<br>        &#125;<br>&#125;ufs;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/description/242/">AcWing240-食物链</a></p><p><a href="https://www.luogu.com.cn/problem/P2024">Luogu2024-食物链</a></p><p>（这是同一道题~话说洛谷的题号真吉利(～￣▽￣)～）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1.5e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Union_Find_Set</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> n,p[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            n=x;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>                p[i]=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(p[x]!=x)p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>            <span class="hljs-keyword">return</span> p[x];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            a=<span class="hljs-built_in">find</span>(a);b=<span class="hljs-built_in">find</span>(b);<br>            p[a]=b;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b);<br>        &#125;<br>&#125;ufs;<br><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> d,x,y;<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;k;<br>    ufs.<span class="hljs-built_in">init</span>(n*<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        cin&gt;&gt;d&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(x&gt;n||y&gt;n)&#123;<br>            ans++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(d==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(ufs.<span class="hljs-built_in">same</span>(x,y+n)||ufs.<span class="hljs-built_in">same</span>(x+n,y))&#123;<br>                ans++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            ufs.<span class="hljs-built_in">merge</span>(x,y);<br>            ufs.<span class="hljs-built_in">merge</span>(x+n,y+n);<br>            ufs.<span class="hljs-built_in">merge</span>(x+n+n,y+n+n);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(ufs.<span class="hljs-built_in">same</span>(x,y)||ufs.<span class="hljs-built_in">same</span>(x,y+n))&#123;<br>                ans++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            ufs.<span class="hljs-built_in">merge</span>(x+n,y);<br>            ufs.<span class="hljs-built_in">merge</span>(x+n+n,y+n);<br>            ufs.<span class="hljs-built_in">merge</span>(x,y+n+n);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>树论</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Trie_Tree字典树</title>
    <link href="/2024/08/02/Trie-Tree/"/>
    <url>/2024/08/02/Trie-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>听起来很高大上，事实上很简单（￣︶￣）</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>快速存储和查询字符串。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>首先建立一颗树，根节点为空节点。</p><ul><li>插入时，一个字符一个字符地插入，每一个字符都作为上一个字符的子节点存在。如果上一个字符有对应的子节点，就直接进行下一个字符的操作；如果没有，就先新建一个，然后再进行下一步操作。最后一个字符打一个标记，表示这里有一个单词。（如果需要还可以储存下个数）</li><li>查询时，也是一个字符一个字符查询。如果某个节点没有下一个字符的子节点，或者最后一个节点处没有打标记，就说明没有这个单词，否则就有这个单词。</li></ul><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">trie_tree</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>],cnt[N],idk;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string str)</span></span>&#123;<br>            <span class="hljs-type">int</span> now=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();i++)&#123;<br>                <span class="hljs-type">int</span> t=str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(!son[now][t])son[now][t]=++idk;<br>                now=son[now][t];<br>            &#125;<br>            cnt[now]++;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(string str)</span></span>&#123;<br>            <span class="hljs-type">int</span> now=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();i++)&#123;<br>                <span class="hljs-type">int</span> t=str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(!son[now][t])<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                now=son[now][t];<br>            &#125;<br>            <span class="hljs-keyword">return</span> cnt[now];<br>        &#125;<br>&#125;tt;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1><p><em>写了几篇费脑博客，再写这篇，真的热泪盈眶(≧∇≦)</em></p>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>树论</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-KMP</title>
    <link href="/2024/08/02/KMP/"/>
    <url>/2024/08/02/KMP/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>KMP真的<strong>很不好理解</strong>，但其实理解了原理，<strong>代码就没有任何的问题了</strong>。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="总概"><a href="#总概" class="headerlink" title="总概"></a>总概</h2><p>KMP嘛，其实就是优化字符串匹配的过程。</p><p>优化的终点就是当前点匹配不上时的操作。对比如下：</p><ul><li>暴力算法：后移一位，从头开始匹配。</li><li>KMP算法：找到匹配串中距离当前点最近的可以与被匹配串匹配的点，直到当前点可以匹配为止。</li></ul><p>（这句话可能有点绕，但学完整个算法就理解了。）</p><p>（至于为什么把它分在数据结构……<del>你就说next数组存没存数据吧</del>）</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>整个KMP算法其实分为两步：</p><ol><li>找next数组</li><li>匹配！</li></ol><p>至于具体怎么做，马上就知道了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="找next数组"><a href="#找next数组" class="headerlink" title="找next数组"></a>找next数组</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>next数组，其实就是寻找如果当前点匹配不上，<strong>上一个最近的可以匹配的点</strong>。重点，就在于如何判断<strong>可以匹配</strong>。</p><p>假设被匹配字符串到了第i个元素，匹配字符串到了第j个元素，那么可以肯定的是，两个字符串当前元素前面的元素，一定是完全相等的。<em>不然就没法匹配当前元素了~</em></p><ul><li>如果当前元素相同，那最好，i和j各自前进一位，把刚才进行匹配的元素加入前面已经完成匹配的部分中。</li><li>如果当前元素不同，那就到了next数组发挥作用的时候了。</li></ul><p>将两个字符串中已经匹配好的子串单独拿出来（包括被匹配串中移出的部分），可以看出，被匹配串的后缀，与匹配串是完全相同的。</p><p>之所以这样，是因为在匹配的过程中，匹配串肯定是从前往后进行匹配的，因此它的前缀必须先完成匹配。在这个匹配过程中，匹配串肯定是在向后移动，那么被匹配串中肯定就有元素匹配不上，那么这些元素就全都排在当前完成匹配的元素的前面，所以当前被匹配串子串的后缀肯定是完成匹配了的。</p><p>（这里不是说被匹配串整个串，只是当前对比元素的前面形成的完成匹配的子串）</p><p>所以可以得出，前缀与被匹配串的后缀相同的匹配串可以进行匹配。</p><p>那么上一个可以进行匹配的元素，肯定也满足这个性质。</p><p>当前的子串与被匹配串后缀相等，但是后一个元素无法匹配，就需要找到上一个在匹配串中满足条件的子串，用它的后一位元素再与被匹配串中当前匹配元素匹配。</p><p><strong>所以新的元素的前缀也要与被匹配串的后缀相同。</strong></p><p><strong>而被匹配串的当前的最大相同后缀，其实就是匹配串当前已经完成匹配的子串。</strong></p><p><strong>后缀的后缀和前缀的前缀一定相同。</strong></p><p><strong>所以也就是要找到匹配串前缀中最长的前缀，与被匹配串后缀中最长的后缀相同。</strong></p><p><strong>联立第二句话与第四句话，当前最长的满足条件的子串就是当前匹配串子串中最大公共前后缀。</strong></p><p><strong>所以下一个匹配的元素就是最大公共前缀的后一位。也就是next数组中的存储的东西了。</strong></p><p>归根结底，找next数组的过程，其实就是不断找最大公共前后缀的过程。</p><p>找的是当前匹配元素之前形成的子串中的最大前缀的后一位元素。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>现在问题就变成了找当前元素之前的子串（不包括当前元素）的最长公共前后缀大小的问题。</p><p>假设已经完成了第i个元素，它的next是j。<br>（相当于从第1个元素到第i-1个元素形成的子串中，最长公共前后缀长度是j-1）</p><p>现在，我们就对比元素i与元素j。</p><ul><li>如果相同，那么<code>next[i+1]=j+1</code>，因为后缀新加入了一个与前缀新加入的元素相同的元素，还是最长公共前后缀，长度增加了一。最后<code>j++, i++</code>就行了。</li><li>如果不同，也就相当于两个字符串匹配的过程，j不断地去找上一个满足条件的元素<code>j=next[j]</code>，直到当前元素j与元素i相同为止，<code>next[i+1]=j+1</code>，然后<code>j++, i++</code>。</li><li>如果所有元素都不同，特计<code>next[i+1]=0</code>，表示无法匹配，后移一位重启匹配。</li></ul><p>然后一直循环，直到整个匹配串找完为止。</p><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>怎么匹配？其实就跟找next数组一模一样，不过并不是对比同一个字符串的前后缀，而是匹配匹配串的前缀和被匹配串的后缀罢了。</p><p>思路其实是完全相同的。当匹配串完成了最后一个元素的匹配时，就说明整个串都完成匹配了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://www.acwing.com/problem/content/description/833/">AcWing831-KMP字符串</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>,M=<span class="hljs-number">1e6</span><span class="hljs-number">+6</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">char</span> p[N],s[M];<br><span class="hljs-type">int</span> ne[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;p<span class="hljs-number">+1</span>&gt;&gt;m&gt;&gt;s<span class="hljs-number">+1</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||p[i]==p[j]) ne[++i]=++j;<br>        <span class="hljs-keyword">else</span> j=ne[j];<br>    &#125;<br>    i=j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=m)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||s[i]==p[j]) i++,j++;<br>        <span class="hljs-keyword">else</span> j=ne[j];<br>        <span class="hljs-keyword">if</span>(j==n<span class="hljs-number">+1</span>)&#123;<br>            cout&lt;&lt;i-n<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            j=ne[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1><p><em>愉快地亖了</em></p>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Monotonic_Queue单调队列</title>
    <link href="/2024/08/01/Monotonic-Queue/"/>
    <url>/2024/08/01/Monotonic-Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>update2024&#x2F;08&#x2F;07: 写的太乱了，刚好后面动规要引用，回来看了一眼不堪直视，遂重写</em></p><p>单调队列，在STL中有<code>priority_queue</code>（其实人家是堆hh），但事实上和单调队列还是有差距的，详见正文。</p><p>而滑动窗口，就是利用单调队列思想，实现的一种算法。</p><p>本博客会在单调栈的基础上讲解，所以不会的自助吧。</p><p><a href="https://githarlem.github.io/2024/08/01/Monotonic-Stack/">“[编程笔记]-Monotonic_Stack单调栈”</a></p><p><a href="https://githarlem.github.io/2024/08/01/Queue/">“[编程笔记]-Queue队列”</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>具有单调性的队列。</p><p>具体的，事实上，它是一个双端队列，可以完成队头、队尾的插入删除操作。</p><p>如果你想维护单调性，肯定是需要维护队尾的不是么。</p><p>因此，单调队列和单调栈的唯一区别，就是需要从队头删除元素。</p><p>但是从队头删除元素就和单调性无关了。通常的，题目中都会有对于队列的限制，比如说限制队列长度之类的。为了维护这些性质，我们就需要从队头删除元素了（当然，如果题目没有要求，理论上来说你从队尾删除也没有任何问题，因此使用滑动窗口的题目中都会有要求的）。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>相对于一个数据结构单调栈来说，单调队列其实更有灵活性，并且表现得像一种思想或者说是算法。</p><p>当然你也可以用双端队列进行模拟，但介于那就是单调栈加上一些队头维护操作，那些操作还得根据题目要求来，就没有必要再给出模板了，直接找单调栈的即可。</p><p>所以就直接给例题吧。</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>开个部分告诉你，会在例题中讲解滑动窗口问题。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/156/">AcWing154-滑动窗口</a></p><p>值得注意的是：它用的也就是滑动窗口算法，只是说滑动窗口算法不只是这道题中的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//手打双端队列模拟滑动窗口</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span><span class="hljs-number">+6</span>;<br><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-type">int</span> h1,t1,h2,t2;<br><span class="hljs-type">int</span> s1[N],s2[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(h1&lt;t1&amp;&amp;i-s1[h1<span class="hljs-number">+1</span>]<span class="hljs-number">+1</span>&gt;k)h1++;<br>        <span class="hljs-keyword">while</span>(h1&lt;t1&amp;&amp;a[s1[t1]]&gt;=a[i])t1--;<br>        s1[++t1]=i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k)cout&lt;&lt;a[s1[h1<span class="hljs-number">+1</span>]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(h2&lt;t2&amp;&amp;i-s2[h2<span class="hljs-number">+1</span>]<span class="hljs-number">+1</span>&gt;k)h2++;<br>        <span class="hljs-keyword">while</span>(h2&lt;t2&amp;&amp;a[s2[t2]]&lt;=a[i])t2--;<br>        s2[++t2]=i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k)cout&lt;&lt;a[s2[h2<span class="hljs-number">+1</span>]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>队列</tag>
      
      <tag>手打STL</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Monotonic_Stack单调栈</title>
    <link href="/2024/08/01/Monotonic-Stack/"/>
    <url>/2024/08/01/Monotonic-Stack/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>具有单调性的栈（站内元素单调递增或单调递减）</p><h1 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h1><p>问数组中每一个元素左侧&#x2F;右侧离它最近的比它大&#x2F;小的元素是什么。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monotonic_Stack</span>&#123;<span class="hljs-comment">//这里是单调递减，要改的话改fix()就行了。</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> a[N];<br>        <span class="hljs-type">int</span> size;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> size==<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a[size];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>            size--;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fix</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//维护单调性</span><br>            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">empty</span>()&amp;&amp;<span class="hljs-built_in">top</span>()&gt;=x)<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//单调插入</span><br>            <span class="hljs-built_in">fix</span>(x);<br>            a[++size]=x;<br>        &#125;<br>&#125;ms;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>就是上面说的经典题型。</p><p><a href="https://www.acwing.com/problem/content/832/">AcWing830-单调栈</a></p><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>还是讲解一下吧。</p><p>维护栈单调性可做的证明：</p><p>若a[i]≥a<a href="i%3Cj">j</a>，那么在j之后所有结果可以是i的，j都会是更优解。所以i绝对不可能作为答案出现，可以排除。</p><p>这样，就只需要维护一个单调递增的栈就行了。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monotonic_Stack</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> a[N];<br>        <span class="hljs-type">int</span> size;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> size==<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a[size];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>            size--;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fix</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">empty</span>()&amp;&amp;<span class="hljs-built_in">top</span>()&gt;=x)<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-built_in">fix</span>(x);<br>            a[++size]=x;<br>        &#125;<br>&#125;ms;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        ms.<span class="hljs-built_in">fix</span>(a[i]);<br>        <span class="hljs-keyword">if</span>(!ms.<span class="hljs-built_in">empty</span>()) cout&lt;&lt;ms.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-number">-1</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        ms.<span class="hljs-built_in">push</span>(a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>手打STL</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Queue队列</title>
    <link href="/2024/08/01/Queue/"/>
    <url>/2024/08/01/Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一种先进先出的数据结构，就像排队一样。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Static_Queue</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> front,back;<span class="hljs-comment">//这里front可以视作第0个元素，它的下一位才是第一个真正的元素。</span><br>        <span class="hljs-type">int</span> a[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            a[++back]=x;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>            front++;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> front==back;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a[front<span class="hljs-number">+1</span>];<br>        &#125;<br>&#125;sq;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>队列</tag>
      
      <tag>手打STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Stack栈</title>
    <link href="/2024/08/01/Stack/"/>
    <url>/2024/08/01/Stack/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为STL库自带的数据结构，我就不多详细的解释了，主要记录一下手写的代码。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一种先进后出的数据结构，可以视为有底瓶。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Static_Stack</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> top;<br>        <span class="hljs-type">int</span> a[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            a[++top]=x;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>            top--;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> top==<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a[top];<br>        &#125;<br>&#125;ss;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/3305/">AcWing3302-表达式求值</a></p><p>经典例题，并且不是很好写，故留作记录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>stack&lt;<span class="hljs-type">char</span>&gt; ops;<br><br>string str;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> op=ops.<span class="hljs-built_in">top</span>();ops.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> n2=nums.<span class="hljs-built_in">top</span>();nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> n1=nums.<span class="hljs-built_in">top</span>();nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;+&#x27;</span>)<span class="hljs-keyword">return</span> n1+n2;<br>    <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;-&#x27;</span>)<span class="hljs-keyword">return</span> n1-n2;<br>    <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;*&#x27;</span>)<span class="hljs-keyword">return</span> n1*n2;<br>    <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;/&#x27;</span>)<span class="hljs-keyword">return</span> n1/n2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;str;<br>    <span class="hljs-type">int</span> t;<span class="hljs-type">bool</span> pd;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t=<span class="hljs-number">0</span>;pd=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(str[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;str[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            pd=<span class="hljs-literal">true</span>;<br>            t=t*<span class="hljs-number">10</span>+(str[i++]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pd) nums.<span class="hljs-built_in">push</span>(t);<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;*&#x27;</span>||str[i]==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>()&amp;&amp;(ops.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;*&#x27;</span>||ops.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;/&#x27;</span>))&#123;<br>                nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">count</span>());<br>            &#125;<br>            ops.<span class="hljs-built_in">push</span>(str[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;+&#x27;</span>||str[i]==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>()&amp;&amp;ops.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">count</span>());<br>            &#125;<br>            ops.<span class="hljs-built_in">push</span>(str[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            ops.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(ops.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">count</span>());<br>            &#125;<br>            ops.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>())&#123;<br>        nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">count</span>());<br>    &#125;<br>    cout&lt;&lt;nums.<span class="hljs-built_in">top</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>手打STL</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Double-Linked_Lists双链表</title>
    <link href="/2024/08/01/Double-Linked-Lists/"/>
    <url>/2024/08/01/Double-Linked-Lists/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>鉴于双链表和单链表基本上一毛一样，所以不会重新再写一遍链表基本操作，详见<a href="https://githarlem.github.io/2024/08/01/Single-Linked-Lists/">“[编程笔记]-Single-Linked_Lists单链表”</a>。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>就是双向链表，每个节点既指向后一个元素，又指向前一个元素。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><em>对没错就是这么懒( •̀ ω •́ )✧</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Double_linked_lists</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> head,tail,cnt;<br>        <span class="hljs-type">int</span> e[N],ne[N],la[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> h=<span class="hljs-number">0</span>)</span></span>&#123;<br>            head=h;tail=n<span class="hljs-number">+1</span>;<br>            ne[head]=tail;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_next</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<br>            ++cnt;<br>            e[cnt]=x;<br>            ne[cnt]=ne[k];<br>            ne[k]=cnt;<br>            la[cnt]=k;<br>            la[ne[cnt]]=cnt;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_last</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//其实这里可以直接转成add_next()，但为了方便学习还是手打了一遍。</span><br>            ++cnt;<br>            e[cnt]=x;<br>            la[cnt]=la[k];<br>            la[k]=cnt;<br>            ne[la[cnt]]=cnt;<br>            ne[cnt]=k;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//删除编号为k的节点。</span><br>            ne[la[k]]=ne[k];<br>            la[ne[k]]=la[k];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ne[head];i!=tail;i=ne[i])&#123;<br>                vec.<span class="hljs-built_in">push_back</span>(e[i]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> vec;<br>        &#125;<br>&#125;dll;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Single-Linked_Lists单链表</title>
    <link href="/2024/08/01/Single-Linked-Lists/"/>
    <url>/2024/08/01/Single-Linked-Lists/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开新章啦。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>链表中，每一个元素都有一个指向下一个元素的指针，这样一个链接一个，就形成了一个链式结构。</p><h1 id="动态链表"><a href="#动态链表" class="headerlink" title="动态链表"></a>动态链表</h1><p>动态链表通常就是真正意义上的链表，可以动态增加、修改、减少，但事实上用处并不大，这里就只给出模板，用以借鉴。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<span class="hljs-comment">//组成链表的结点</span><br><span class="hljs-type">int</span> data;<br>node* next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>在竞赛中，静态链表才是大头。同时，在之后，我们会学到<strong>链式前向星</strong>，与链表的关系不能说微乎其微，也只能说是一模一样。</p><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>拿数组去模拟链表。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>同时开两个数组，储存对应<strong>编号</strong>的节点的数据和下一个节点的<strong>编号</strong>（编号不是元素在链表中的位置序号！）</p><p>这样就能通过修改对应数组的方式实现链表操作。</p><p>具体功能在代码中给出</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Static_linked_list</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> head,tail,cnt;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">注意，头指针并不是第一个元素，而是指向第一个元素的指针，可以视作第零号元素。</span><br><span class="hljs-comment">尾指针同理，并不是最后一个元素，而是最后一个元素指向的元素，作为结束的标志。</span><br><span class="hljs-comment">*/</span><br>        <span class="hljs-type">int</span> ne[N],e[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> h=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>)</span></span>&#123;<br>            head=h;tail=t;<br>            ne[head]=tail;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//在**编号为k**的元素**后**增加一个新元素。</span><br>            ++cnt;<span class="hljs-comment">//这就是编号，所以和位置没有任何关系。</span><br>            e[cnt]=x;<br>            ne[cnt]=ne[k];<br>            ne[k]=cnt;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//删除**编号为k**的元素**后**一位元素。</span><br>            ne[k]=ne[ne[k]];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//获取当前链表</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; lis;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ne[head];i!=tail;i=ne[i])&#123;<br>                lis.<span class="hljs-built_in">push_back</span>(e[i]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> lis;<br>        &#125;<br>&#125;sll;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/828/">AcWing826-单链表</a></p><p>一道模板题。</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Discretization离散化</title>
    <link href="/2024/07/31/Discretization/"/>
    <url>/2024/07/31/Discretization/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>离散化和哈希差不多，但是还是有点区别。</p><ul><li>离散化中元素按顺序获取地址，与元素值没有直接关联；而哈希中元素地址就是元素数值通过哈希函数获得的。</li><li>离散化需要二分预处理出所有地址，哈希是查询时在线计算地址。</li></ul><p>如果有需要，可以看看哈希：</p><p><a href="https://githarlem.github.io/2024/08/02/Hash-Table/">“[编程笔记]-Hash_Table哈希表”</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当遇到数值地址范围很大、数值量很少的问题时，可以使用离散化（或哈希）。</p><p>对原数组中所有地址进行排序、去重，然后记录每个地址对应的新地址，再用新地址储存元素，需要旧地址时以新地址为下标查询完成排序去重的数组即可。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//排序</span><br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>()),vec.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//去重</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:orgn)&#123;<span class="hljs-comment">//用pair储存加值操作，这里执行</span><br><span class="hljs-type">int</span> x=<span class="hljs-built_in">bfind</span>(item.first)<span class="hljs-comment">//二分查询新地址</span><br><span class="hljs-type">int</span> c=item.second;<span class="hljs-comment">//加值</span><br>a[x]+=c;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/804/">AcWing802-区间和</a></p><p>这是一道融合了前缀和、二分查找、离散化的<del>毒瘤</del>好题，值得一刷。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span><span class="hljs-number">+5</span>;<span class="hljs-comment">//增值操作一次一个地址，查询操作一次两个地址，一共三倍的大小。</span><br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,c;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-type">int</span> a[N],s[N];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; locs;<span class="hljs-comment">//储存所有地址</span><br>vector&lt;pii&gt; add,ask;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfind</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<span class="hljs-comment">//这里本来应该有个二分，但是我懒（￣︶￣）不会的可以去二分那一篇笔记看最后的拓展</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(locs.<span class="hljs-built_in">begin</span>(),locs.<span class="hljs-built_in">end</span>(),num)-locs.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+1</span>;<span class="hljs-comment">//之所以加一是为了方便前缀和</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dis</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sort</span>(locs.<span class="hljs-built_in">begin</span>(),locs.<span class="hljs-built_in">end</span>());<br>    locs.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(locs.<span class="hljs-built_in">begin</span>(),locs.<span class="hljs-built_in">end</span>()),locs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:add)&#123;<br>        x=<span class="hljs-built_in">bfind</span>(item.first);<br>        c=item.second;<br>        a[x]+=c;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;c);<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;);<br>        locs.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        ask.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>        locs.<span class="hljs-built_in">push_back</span>(l);<br>        locs.<span class="hljs-built_in">push_back</span>(r);<br>    &#125;<br>    <span class="hljs-built_in">dis</span>();<span class="hljs-comment">//离散化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;locs.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>;i++)&#123;<span class="hljs-comment">//因为所有地址手动加了1，所以最大值也要加1。</span><br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:ask)&#123;<br>        l=<span class="hljs-built_in">bfind</span>(item.first);<br>        r=<span class="hljs-built_in">bfind</span>(item.second);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>离散化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Lowbit取最小1</title>
    <link href="/2024/07/31/Lowbit/"/>
    <url>/2024/07/31/Lowbit/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>lowbit是树状数组的基础啊，其重要性可想而知。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br><span class="hljs-keyword">return</span> a&amp;-a;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="演算"><a href="#演算" class="headerlink" title="演算"></a>演算</h1><p>众所周知，在二进制中，<code>-a</code>等同于<code>~a+1</code>（a的值取反再加一）</p><p>a取反后，所有1变成0，0变成1，因此在原数中第一个1出现前，全都是1。</p><p>故而，再加上一个一，第一个1前面全部变成0，第一个1本来取反变成0了，进位又变回1，然后就结束了，它后面的数字照样是原数取反的结果。</p><p>这时候进行与运算，那么a中第一个1前面的全都是0，-a中第一个1前面的也全都是0，新数就全是0；</p><p>第一个1后面的全都和原数取反，所以在新数中也是0。故而，就得到了第一个1组成的新数。</p><p>举例：</p><blockquote><p>a&#x3D;1010011000<br><del>a&#x3D;0101100111<br>-a&#x3D;</del>a+1&#x3D;0101101000<br>a&amp;-a&#x3D;1010011000&amp;0101101000&#x3D;0000001000</p></blockquote><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/803/">AcWing801-二进制中1的个数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a,ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> num&amp;-num;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br>        ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(a)&#123;<br>            a-=<span class="hljs-built_in">lowbit</span>(a);<br>            ans++;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Two_Pointers双指针</title>
    <link href="/2024/07/31/Two-Pointers/"/>
    <url>/2024/07/31/Two-Pointers/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近时间紧迫，从这篇文章开始，就着重记笔记了，不再提供详细教程。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>双指针算法，名义上说就是使用两个指针循环（一个或多个）数组，但实际上通常用不到指针。</p><p>一般情况下，双指针算法用于特定情境，将O(n<sup>2</sup>)的时间复杂度简化成O(n)。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>一般情况下，形如下方所示的代码，在满足特定需求的情况下，都可以转化成双指针来做。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i,j))&#123;<br><span class="hljs-comment">//功能代码</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转化成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">check</span>(i,j))&#123;<br>j++;<br>&#125;<br><span class="hljs-comment">//功能代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/801/">AcWing799-最长连续不重复子序列</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">int</span> a[N],s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        s[a[i]]++;<br>        <span class="hljs-keyword">while</span>(s[a[i]]&gt;<span class="hljs-number">0</span>)&#123;<br>            s[a[j++]]--;<br>        &#125;<br>        ans=<span class="hljs-built_in">max</span>(ans,i-j<span class="hljs-number">+1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Adjacent_Difference差分</title>
    <link href="/2024/07/30/Adjacent-Difference/"/>
    <url>/2024/07/30/Adjacent-Difference/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>差分是前缀和的逆运算，因此思想与之差不多。所以，为了更好地理解，如果有需要，请事先阅读<a href="https://githarlem.github.io/2024/07/30/Partial-Sum/">“[编程笔记]-Partial_Sum前缀和”</a>。</p><h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><h2 id="思想及实现"><a href="#思想及实现" class="headerlink" title="思想及实现"></a>思想及实现</h2><p>同理，一维差分也可视为对差分的引入。</p><p>差分作为前缀和的逆运算，定义也与之相反。具体地说，对于数组<code>a[]</code>，**它的差分数组前i项之和等于a[i]**，即为<code>a[i]=b[0]+b[1]+...+b[i]</code>。</p><p>差分的主要作用是快速实现<strong>区间修改</strong>，若要使从<em>l</em>到<em>r</em>的区间内元素同时增加<em>c</em>，令<code>b[i]=a[i]-a[i-1]</code>，则可以<strong>使b数组第l位+c、第r+1位-c，那么从l开始，往后所有元素+c，直到第r+1位恢复原状</strong>。</p><p>上述思想十分重要，将会对后面的二维差分部分有很大帮助。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> l,r,c;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    b[l]+=v;<br>    b[r<span class="hljs-number">+1</span>]-=v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        <span class="hljs-built_in">insert</span>(i,i,a[i]);<span class="hljs-comment">//初始化b数组，视作在第i位增加a[i]大小。</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a[i]=a[i<span class="hljs-number">-1</span>]+b[i];<span class="hljs-comment">//递推实现差分</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><p><strong>难点！难点！难点！</strong></p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先是初始化。为了方便，我这边就直接定义我的算法中差分数组的作用了：</p><p>以原点为左上角、当前点为右下角形成矩阵，当前点的数值，就是差分数组在矩阵内的所有元素之和。</p><p>因此，当前点的数值也就是除去当前点形成的“L”型加上当前点位置上的差分数组。</p><p>鉴于该过程与前缀和中的过程基本上完全一致，只需要调转名称即可，故而就不额外配图，如有需要，前言部分中链接自取。</p><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>然后就是区间修改部分了：</p><h4 id="修改单点的效果"><a href="#修改单点的效果" class="headerlink" title="修改单点的效果"></a>修改单点的效果</h4><p>为了理解算法，我们要先理解如果修改一个点的差分值会发生什么。</p><p>已知每个点的数值与其对应的“L”型有关，又可直接视作它与原点形成的矩阵，因而一旦其矩阵中包含被修改的元素，其数值也会收到影响：</p><p><img src="/2024/07/30/Adjacent-Difference/t0.png" alt="红色为修改元素，图中只有棕色点受影响"></p><p>故而会受到影响的元素图如下：</p><p><img src="/2024/07/30/Adjacent-Difference/t1.png" alt="如图"></p><p>那么现在再去理解区间修改就简单多了。</p><h4 id="步入正轨"><a href="#步入正轨" class="headerlink" title="步入正轨"></a>步入正轨</h4><p>已知受影响区间在当前点的右下角，也就是和前缀和刚好相反的，那么在此就不重复推算思路了，也就是矩阵减去“L”型。</p><p>而差分中无论是矩阵还是“L”型都在右下方，其他与前缀和基本完全一致。</p><p>如果需要详细推演过程麻烦上前言链接自取。</p><h3 id="更新原数组"><a href="#更新原数组" class="headerlink" title="更新原数组"></a>更新原数组</h3><p>根据初始化部分中对于差分数组的定义，我们可以将原数组视作前缀和、差分数组视作前缀和中的原数组，直接代公式即可。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="区间修改-1"><a href="#区间修改-1" class="headerlink" title="区间修改"></a>区间修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    b[x1][y1]+=c;<br>    b[x1][y2<span class="hljs-number">+1</span>]-=c;<br>    b[x2<span class="hljs-number">+1</span>][y1]-=c;<br>    b[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>]+=c;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新原数组-1"><a href="#更新原数组-1" class="headerlink" title="更新原数组"></a>更新原数组</h3><p><code>a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j];</code></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span><span class="hljs-number">+3</span>;<br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> a[N][N],b[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    b[x1][y1]+=c;<br>    b[x1][y2<span class="hljs-number">+1</span>]-=c;<br>    b[x2<span class="hljs-number">+1</span>][y1]-=c;<br>    b[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>]+=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>            <span class="hljs-built_in">insert</span>(i,j,i,j,a[i][j]);<span class="hljs-comment">//初始化b数组</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);<br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            a[i][j]=a[i<span class="hljs-number">-1</span>][j]+a[i][j<span class="hljs-number">-1</span>]-a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+b[i][j];<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>前缀和与差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Partial_Sum前缀和</title>
    <link href="/2024/07/30/Partial-Sum/"/>
    <url>/2024/07/30/Partial-Sum/</url>
    
    <content type="html"><![CDATA[<h1 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h1><h2 id="思想及实现"><a href="#思想及实现" class="headerlink" title="思想及实现"></a>思想及实现</h2><p>这里主要还是引入<strong>前缀和</strong>的思想，这个算法在后面还是挺常用的，可以搭配各种算法，减少时间复杂度。</p><p>前缀和呢，就是一个数组的某段前缀内的所有元素之和。举个栗子，<code>&#123;0,1,2,3,4,5,6&#125;</code>，对于这个数组，前四位的前缀和是<code>0+1+2+3==6</code>，前三位的前缀和是<code>0+1+2==3</code>。</p><p>前缀和的主要作用就是查询一段区间的元素之和。令<code>s[i]</code>表示<code>a[]</code>前i位的和，则<code>a[i]</code>就等于<code>s[i]-s[i-1]</code>。同理可推，<code>a[l]+a[l+1]+a[l+2]+...+a[r-2]+a[r-1]+a[r]</code>就等于<code>s[r]-s[l-1]</code>。</p><p><em>减去<code>s[l-1]</code>的原因：a[l]也在所需要的区间内，因此不能减去a[l]而只需减去a[l]左侧的全部元素。</em></p><p>通常情况下，我们会采取<strong>递推</strong>的方式预处理初前缀和，处理的复杂度是<code>O(n)</code>，而之后单次查询的复杂度则降到了<code>O(1)</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N],s[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> l,r;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从这里开始，我们接触的算法就开始烧脑了。</p><p>鉴于二位前缀和的复杂性（当然其实也没多复杂），我这边会搭配图片进行讲解。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二位前缀和呢，若将数组视作一个矩形（左上角为原点），则前缀和储存的就是以原点为左上角、终点为右下角的矩形内包括的所有元素的和。</p><p>因此，若要求一个点的前缀和，只需求出它对应矩形缺了它这个角形成的“L”型图形内的前缀和，再加上这个点本身的数值即可。具体怎么求“L”，我将会在实现部分中写。</p><p><img src="/2024/07/30/Partial-Sum/init.png" alt="&quot;初始化&quot;"></p><p>接下来就是查询的时候了：</p><p>在二维前缀和问题中，所求问题多半是一段二维区间内的元素和。循序渐进，我们从查询单个元素开始说起：</p><p>（下图中每个方格表示一个元素，实心格子表示待求元素）</p><p><img src="/2024/07/30/Partial-Sum/p0.png" alt="&quot;问题1&quot;"></p><p>其实也很简单，我们只需要把求前缀和的过程反过来就行了：用当前元素前缀和减去那个“L”型元素和即可。</p><p>延伸到一段元素，与单个元素的思路一模一样——用右下角元素的前缀和，减去包裹着整个区间的“L”型即可。</p><p><img src="/2024/07/30/Partial-Sum/p1.png" alt="&quot;问题2&quot;"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>不管是求前缀还是计算区间，重点就是求L型。既然我们已知当前点左侧上侧的全部前缀和，为什么不把这个复杂图形切割成我们已知的图形去做呢？</p><p>很简单，把它分成如图所示的两个前缀和，再减去它们重叠的那部分即可。</p><p><img src="/2024/07/30/Partial-Sum/s0.png" alt="&quot;解决&quot;"></p><p>已经有了思路，下面就直接上公式了:</p><p>求前缀和：<br>s[i][j]&#x3D;s[i][j-1]+s[i-1][j]-s[i-1][j-1]+a[i][j]</p><p>求[x1][y1]到[x2][y2]的元素之和:<br>s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span><span class="hljs-number">+3</span>;<br><br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> a[N][N],s[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>            s[i][j]=s[i][j<span class="hljs-number">-1</span>]+s[i<span class="hljs-number">-1</span>][j]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> x1,y1,x2,y2;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x2][y1<span class="hljs-number">-1</span>]-s[x1<span class="hljs-number">-1</span>][y2]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>前缀和与差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-High_Precision(Mul and Div)[SIM]高精度乘除法（基础版）</title>
    <link href="/2024/07/29/High-Precision-MulDiv-Simple/"/>
    <url>/2024/07/29/High-Precision-MulDiv-Simple/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>鉴于此篇博客用于学习or巩固基础部分，故而这里只记录大数与<code>int</code>类型的小数的乘除计算，大数乘大数将会在<a href="https://githarlem.github.io/High-Precison-MulDiv-Complex">“[编程笔记]-High_Precision(Mul and Div)[COM]高精度乘除法（提高版）”</a>教学。</p><p>emmm就这样吧(。·ω·。)</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>其实就跟<strong>列竖式</strong>差不多，把大数列在下面、小数列在上面，直接乘。</p><p><em>别忘了去前导0~</em></p><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>就是用机器去模拟手写嘛。鉴于除法相较于其他三种计算有些复杂，这里给出详细步骤：</p><ol><li>准备好记录结果与记录余数的变量。</li><li>从最高位开始往最低位遍历大数。</li><li>将余数乘十并加上大数的这一位，作为新的被除数。</li><li>记录新的被除数除以小数的商与新余数。</li><li>去掉前导零。</li></ol><p><em>tips: 如果你用的是<code>vector</code>储存，请在第5步前反转队列。（详见代码）</em></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())t+=a[i]*b;<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)c.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;vector&lt;<span class="hljs-type">int</span>&gt;,<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">div</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">int</span> &amp;b)&#123;<span class="hljs-comment">//同时返回结果和余数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        t=t*<span class="hljs-number">10</span>+a[i];<br>        c.<span class="hljs-built_in">push_back</span>(t/b);<span class="hljs-comment">//注意，这里是从最高位开始往最低位储存，所以最后要先反转过来。</span><br>        t%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(c.<span class="hljs-built_in">begin</span>(),c.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//记得#include&lt;algorithm&gt;</span><br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)c.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> &#123;c,t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-High_Precision(Add and Sub)高精度加减法</title>
    <link href="/2024/07/28/High-Precision-AddSub/"/>
    <url>/2024/07/28/High-Precision-AddSub/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客并不打算多细致地讲解高精度，但是！但是！我会给出代码模板，并且在注释中讲解大多数内容。</p><p>就这样吧。（￣︶￣）</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>emmm<strong>小学数学</strong>会吧？<del>不会您先别看了</del> 就用小学数学的思路做就完事了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这里使用vector储存大数，因为它自带size函数，当然直接用数组也没有问题。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||i&lt;b.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())t+=b[i];<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t)c.<span class="hljs-built_in">push_back</span>(t);<span class="hljs-comment">//最后可能还剩一个进位，不要忘了加回去。</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>update 2024&#x2F;7&#x2F;29: 一种更简洁的写法</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||i&lt;b.<span class="hljs-built_in">size</span>()||t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())t+=b[i];<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//同上</span><br><span class="hljs-comment">//此函数用于判断两个大数大小，下方的减法函数只支持大减小。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>()&gt;b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])<span class="hljs-keyword">return</span> a[i]&gt;b[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//此函数用于大减小，搭配上方函数使用即可。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())t-=b[i];<br>        c.<span class="hljs-built_in">push_back</span>((t<span class="hljs-number">+10</span>)%<span class="hljs-number">10</span>);<span class="hljs-comment">//此处浓缩了两种可能：t&lt;0，返回t+10；t≥0，返回t。</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>)t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)c.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//删除前置0。当只剩一位时不删（不然0就没了）。</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Binary_Search二分查找</title>
    <link href="/2024/07/28/Binary-Search/"/>
    <url>/2024/07/28/Binary-Search/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二分也算是比较普遍且常用的一个算法了，并且在前期还是个小难点，其相对复杂的类型以及边界问题通常让<em>蒟蒻</em>们很是头疼。</p><p>这一篇博客主要讲解<strong>二分查找</strong>的原理、模板等（不是<strong>二分答案</strong>），并不着重深入讲解其各种变式。</p><p>就这样吧(～￣▽￣)～</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>二分查找就是把一段元素分成两半，用中间值进行对比，判断查找元素在其左侧或右侧，并在那一半进行查找，以到达O(logn)的复杂度。</p><p>因此，理论上来说，所有<strong>单调性</strong>问题都可以用二分解决。当然，<strong>并非只有单调性问题才可以用二分解决</strong>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>二分的实现其实并不难，搞清楚原理后，基本上就没什么问题了。</p><p>这里还是大概贴下思路：</p><ol><li>确定搜索范围。</li><li>获取中间值。<strong>！注意，不同二分方式在这一步的具体实现会有所不同，详见下方！</strong></li><li>判断答案在左侧还是右侧。</li><li>在答案所在一侧重新二分，循环直到范围缩为1。</li><li>判断获得元素是否为所求，若否，则搜索范围中无需要元素。</li></ol><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p><em>整数二分有<strong>两种</strong>形式，我个人将其命名为<strong>左倾二分</strong>以及<strong>右倾二分</strong>（非！官！方！命！名！）</em></p><h3 id="左倾二分"><a href="#左倾二分" class="headerlink" title="左倾二分"></a>左倾二分</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>所谓_左倾_，就是说搜索到的答案<strong>倾向于向左侧靠近</strong>。举例地说，当一段元素中有连续的一段相同元素时，搜索此元素，得到的将会是这一段中最左侧的坐标。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>在计算中间坐标时，<strong>向下取整</strong>。原因会在第二点给出。</li><li>若中间值<strong>大于或等于</strong>答案，则将右边界重设为中间坐标。<strong>因此，中间坐标需向下取整，否则会陷入死循环</strong>。</li><li>否则，将左边界重设为中间坐标**+1**，原因是中间坐标已经确定不是答案，因此不在搜索范围内。</li></ul><h4 id="左倾原因"><a href="#左倾原因" class="headerlink" title="左倾原因"></a>左倾原因</h4><p>若当前搜索范围内值都一致，则都满足<strong>大于或等于</strong>答案，那么会一直重设右边界。同时，中间坐标向下取整，故而范围会一直向左缩小，直到缩小至一个元素，那么就是最左侧的元素了。</p><h3 id="右倾二分"><a href="#右倾二分" class="headerlink" title="右倾二分"></a>右倾二分</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>_右倾_定义可借鉴_左倾_，就是说搜索到的答案<strong>倾向于向右侧靠近</strong>，这里就不做具体阐释。</p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>在计算中间坐标时，<strong>向上取整</strong>。原因会在第三点给出。</li><li>若中间值<strong>大于</strong>答案，则将右边界重设为中间坐标**-1**，原因是中间坐标已经确定不是答案，因此不在搜索范围内。</li><li>否则，将左边界重设为中间坐标。<strong>因此，中间坐标需向上取整，否则会陷入死循环</strong>。</li></ul><h4 id="右倾原因"><a href="#右倾原因" class="headerlink" title="右倾原因"></a>右倾原因</h4><p>若当前搜索范围内值都一致，则都满足<strong>小于或等于</strong>答案，那么会一直重设左边界。同时，中间坐标向上取整，故而范围会一直向右缩小，直到缩小至一个元素，那么就是最右侧的元素了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><em>代码中check函数不固定，视需求而定</em></p><h4 id="左倾二分-1"><a href="#左倾二分-1" class="headerlink" title="左倾二分"></a>左倾二分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(m))r=m;<br>    <span class="hljs-keyword">else</span> l=m<span class="hljs-number">+1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="右倾二分-1"><a href="#右倾二分-1" class="headerlink" title="右倾二分"></a>右倾二分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> m=l+r<span class="hljs-number">+1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(m))r=m<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> l=m;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>浮点数二分相对于整数二分来说简单了很多，但需要注意的是，通常情况下是不能真正搜索到答案的，因此，当当前值与答案之间的差距足够小时，<strong>我们就视之为答案即可</strong>。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和整数二分差不多，取中间值时不存在取整问题，边界开闭随个人喜好。</p><p><strong>循环条件要写成边界之差大于一个较小值！（通常为1e-6以下，具体要求随题目而定）</strong></p><p><em>tips: 若题目有要求，则差值至少比保留小数位数多两位。</em></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> l=<span class="hljs-number">0</span>,r=x;<br><span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-6</span>)&#123;<br><span class="hljs-type">double</span> m=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(m))r=m;<br><span class="hljs-keyword">else</span> l=m;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p><em>update: 2024&#x2F;7&#x2F;31</em><br>STL库中有两个快速实现二分查找的函数。</p><h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound()"></a>upper_bound()</h2><p>查询第一个<strong>大于</strong>要求值的数，返回其<strong>迭代器</strong>。</p><p>故而，如果要获得其坐标，记得减去第一个元素的迭代器。</p><p>模板以<code>vector</code>为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfind</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">upper_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),num)-vec.<span class="hljs-built_in">begin</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound()"></a>lower_bound()</h2><p>和上一个差不多，查询第一个<strong>大于等于</strong>要求值的数，返回其<strong>迭代器</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfind</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),num)-vec.<span class="hljs-built_in">begin</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>搜索</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Merge_Sort归并排序</title>
    <link href="/2024/07/27/Merge-Sort/"/>
    <url>/2024/07/27/Merge-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>利用<strong>分治思想</strong>，把数组对半分成两份，各自排好序，再将两个排好序的数组合并成一个数组即可。</p><p>（或许有点废话？Σ(っ °Д °;)っ）</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>这里着重讲以下合并数组的过程：</p><ol><li><p>建立两个指针，指向两边各排好序的数组的首个元素。</p></li><li><p>对指针指向的元素进行对比，更小的（从小到大排序）插入临时数组，直到其中一个指针走到结尾。</p></li><li><p>把两个数组中剩下的元素插入临时数组（其实只会有一个有余，这里不做解释）</p></li><li><p>用临时数组替换原数组中对应元素段。</p></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N],t[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ms</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">ms</span>(l,m);<span class="hljs-built_in">ms</span>(m<span class="hljs-number">+1</span>,r);<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=m<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j])t[k++]=a[i++];<br><span class="hljs-keyword">else</span> t[k++]=a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=m)t[k++]=a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)t[k++]=a[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)a[i]=t[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">ms</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Quick_Sort快速排序</title>
    <link href="/2024/07/26/Quick-Sort/"/>
    <url>/2024/07/26/Quick-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h2><p>利用<strong>分治思想</strong>，新建两个数组，分别储存原数组中小于 X 或大于 X 的元素，并分别对其进行快速排序，最后重组原数组即可。（X可为任意值，推荐使用中值）</p><h2 id="进化版"><a href="#进化版" class="headerlink" title="进化版"></a>进化版</h2><p>利用<strong>分治思想</strong>以及部分<strong>双指针思想</strong>，左右各两个指针，记为 i, j。左指针一直向右，直到数组中第 i 个元素大于 x；右指针一直向左，直到数组中第 j 个元素小于x；接着左右指针<strong>对应元素</strong>互换，重复执行直到左右指针相遇。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>平均O(nlogn)，最大O(n<sup>2</sup>)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> x=q[l+r&gt;&gt;<span class="hljs-number">1</span>],i=l<span class="hljs-number">-1</span>,j=r<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(q[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(q[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q,l,j);<br>    <span class="hljs-built_in">quick_sort</span>(q,j<span class="hljs-number">+1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h1 id="蒟蒻的个人简介"><a href="#蒟蒻的个人简介" class="headerlink" title="蒟蒻的个人简介"></a>蒟蒻的个人简介</h1><h2 id="OIer"><a href="#OIer" class="headerlink" title="OIer"></a>OIer</h2><p>emmm目前就是个普三蒟蒻</p><p>所以究竟是哪个缺德学校把重庆变成强省的，我不说，自己对号入座 </p><p>凸(艹皿艹 )</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>好像还行？[雾]</p><p>虽然全校前百，但也只是个蒟蒻</p><p>(～￣▽￣)～</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>国内手游什么的完全无感（一堆抄袭怪）</p><p>P社<del>战犯</del>大元帅，五星好市民，以及别的一些小众，这个不重要，就提一嘴</p><p>（￣︶￣）</p><p>另外，求一个小灰立绘美化mod</p><p>( •̀ ω •́ )✧</p><h1 id="蒟蒻的中-ruo-二-zhi-身份"><a href="#蒟蒻的中-ruo-二-zhi-身份" class="headerlink" title="蒟蒻的中(ruo)二(zhi)身份"></a>蒟蒻的中(ruo)二(zhi)身份</h1><p>tips：非自愿，都是被<a href="https://www.luogu.com.cn/user/775936">Mingrui_Yang</a>大佬逼得。</p><h2 id="杨坤神教大主教"><a href="#杨坤神教大主教" class="headerlink" title="杨坤神教大主教"></a>杨坤神教大主教</h2><p>不是教主，教主是<a href="https://www.luogu.com.cn/user/775936">Mingrui_Yang</a>大佬。</p><p>不过我是圣主派的，他是正主派的，具体关系详见<a href="https://www.luogu.com.cn/problem/U456153">这道未完成烂题</a>。</p><p><em>顺便求下正解和数据，我们将会给大佬提供杨坤神教大主教之位！</em> </p><p><em>本蒟蒻的位子直接禅让了也可以</em> ヽ(￣ω￣(￣ω￣〃)ゝ</p><p>顺便宣传下，<a href="https://www.luogu.com.cn/team/61978">杨坤神教</a>，不违法，不摄政，团(fen)结(beng)一(li)新(xi)，共(feng)同(kuang)进(nei)步(juan)，中二骚年的最好选择！</p><p><del>我是<strong>自愿</strong>的(ノへ￣、)</del></p><h2 id="大元帅"><a href="#大元帅" class="headerlink" title="大元帅"></a>大元帅</h2><p>emmm这个不好多说，总之欢迎各位志同道合的同志们加入我们的<a href="https://www.luogu.com.cn/team/84599">团队</a></p><hr><p>THEEND</p>]]></content>
    
  </entry>
  
  
  
</search>
