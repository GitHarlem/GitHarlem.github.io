<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法笔记-Merge_Sort归并排序</title>
    <link href="/2024/07/27/Merge-Sort/"/>
    <url>/2024/07/27/Merge-Sort/</url>
    
    <content type="html"><![CDATA[<p>#原理<br>利用<strong>分治思想</strong>，把数组对半分成两份，各自排好序，再将两个排好序的数组合并成一个数组即可。</p><p>（或许有点废话？Σ(っ °Д °;)っ）</p><p>#实现<br>这里着重讲以下合并数组的过程：</p><ol><li><p>建立两个指针，指向两边各排好序的数组的首个元素。</p></li><li><p>对指针指向的元素进行对比，更小的（从小到大排序）插入临时数组，直到其中一个指针走到结尾。</p></li><li><p>把两个数组中剩下的元素插入临时数组（其实只会有一个有余，这里不做解释）</p></li><li><p>用临时数组替换原数组中对应元素段。</p></li></ol><p>#代码<br>    #include&lt;bits&#x2F;stdc++.h&gt;<br>    using namespace std;</p><pre><code class="hljs">const int N=1e5+5;int n;int a[N],t[N];void ms(int l,int r)&#123;     if(l&gt;=r)return;    int m=l+r&gt;&gt;1;    ms(l,m);ms(m+1,r);    int k=0,i=l,j=m+1;    while(i&lt;=m&amp;&amp;j&lt;=r)&#123;        if(a[i]&lt;=a[j])t[k++]=a[i++];        else t[k++]=a[j++];    &#125;    while(i&lt;=m)t[k++]=a[i++];    while(j&lt;=r)t[k++]=a[j++];    for(int i=l,j=0;i&lt;=r;i++,j++)a[i]=t[j];&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    ms(0,n-1);    for(int i=0;i&lt;n;i++)printf(&quot;%d &quot;,a[i]);    return 0;&#125;</code></pre><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法笔记-Quick_Sort快速排序</title>
    <link href="/2024/07/26/Quick-Sort/"/>
    <url>/2024/07/26/Quick-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h2><p>利用<strong>分治思想</strong>，新建两个数组，分别储存原数组中小于 X 或大于 X 的元素，并分别对其进行快速排序，最后重组原数组即可。（X可为任意值，推荐使用中值）</p><h2 id="进化版"><a href="#进化版" class="headerlink" title="进化版"></a>进化版</h2><p>利用<strong>分治思想</strong>以及部分<strong>双指针思想</strong>，左右各两个指针，记为 i, j。左指针一直向右，直到数组中第 i 个元素大于 x；右指针一直向左，直到数组中第 j 个元素小于x；接着左右指针<strong>对应元素</strong>互换，重复执行直到左右指针相遇。</p><p>#复杂度<br>平均O(nlogn)，最大O(n<sub>2</sub>)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="hljs">#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n;int q[N];void quick_sort(int q[],int l,int r)&#123;    if(l&gt;=r)return;    int x=q[l+r&gt;&gt;1],i=l-1,j=r+1;    while(i&lt;j)&#123;        do i++;while(q[i]&lt;x);        do j--;while(q[j]&gt;x);        if(i&lt;j)swap(q[i],q[j]);    &#125;    quick_sort(q,l,j);    quick_sort(q,j+1,r);&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;q[i]);    quick_sort(q,0,n-1);    for(int i=0;i&lt;n;i++)printf(&quot;%d &quot;,q[i]);    return 0;&#125;</code></pre><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
