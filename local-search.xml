<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[编程笔记]-Floyd</title>
    <link href="/2024/08/04/Floyd/"/>
    <url>/2024/08/04/Floyd/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>你以为这篇最短路和其他最短路差了一天的时间吗？不，实际上只差了一个小时(ノへ￣、)</em></p><p><strong>现在是00: 24</strong></p><p><strong>半夜三更发癫很正常，如有发癫您就别管那点鸡毛小事了hhh</strong></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>用于多源汇最短路问题，也就是有多个源点的最短路问题。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li>邻接矩阵存储所有的边</li><li>直接上三重循环。啊就是找起点终点和跳板点然后通过跳板点更新dis嘛不想解释了看代码吧。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>dis[i][j]=<span class="hljs-built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>你以为它是暴力？哈哈哈其实别人是基于动规的hhh。</p><p>这才是它的本来面貌：<br><code>d[k][i][j]=d[k-1][i][k]+d[k-1][k][j]</code><br>然后大佬把第一维给优化掉了hhh</p><p>所以要先循环k的hhh</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>其实模板上面已经给了，所以这里直接上例题吧。</p><p><a href="https://www.acwing.com/problem/content/856/">AcWing854-Floyd求最短路</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">202</span>;<br><br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> x,y,z;<br><span class="hljs-type">int</span> d[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                d[i][j]=<span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(d));<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        d[x][y]=<span class="hljs-built_in">min</span>(d[x][y],z);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)d[i][i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(d[x][y]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>)cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<span class="hljs-comment">//防止原本到不了的元素之间的负边导致终点减少。</span><br>        <span class="hljs-keyword">else</span> cout&lt;&lt;d[x][y];<br>        cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>Floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-SPFA</title>
    <link href="/2024/08/03/SPFA/"/>
    <url>/2024/08/03/SPFA/</url>
    
    <content type="html"><![CDATA[<h1 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h1><p><del>关于SPFA，它亖了</del></p><p>就是对Bellman-Ford算法的一种优化。<del>事实证明优化地很成功，直接给BF差不多干没了</del></p><p>可以得出，节点i路程变化，当且仅当指向i的节点的路程变化，然后就能写出一个接近bfs的算法。</p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>通常情况下，SPFA是快于Dijkstra的。</p><p>！！！但是！SPFA它<del>亖了</del>容易被卡啊！被卡了就真亖了！！！</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li>把起点插入队列</li><li>取出队头，更新队头的所有出边。</li><li>每个更新成功的出边，都把另一个节点插入队列。</li><li>重复执行2、3步直到队列为空。</li></ol><p><em>有没有发现长得很像堆优化的Dijkstra？像就对了(^▽^)</em></p><p><strong>注意：不同于Dij，SPFA存储的判断数组是判断元素是否在队列中（可重复访问），而Dij的是判断元素有没有被访问过（不可重复访问）</strong></p><p><strong>同时，因为负环的存在，是不存在“剪枝”操作的~</strong></p><h1 id="判断负环"><a href="#判断负环" class="headerlink" title="判断负环"></a>判断负环</h1><p>顺便记录一下路径经过的点个数，如果个数超过n，就说明有环了。这个环还能被更新，就说明它是个<strong>负环</strong>。</p><p>注意，开始时<strong>所有点都是起点</strong>。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1.5e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y,z;<br><span class="hljs-type">int</span> dis[N];<br><br><span class="hljs-type">int</span> idk;<br><span class="hljs-type">int</span> hd[N],ne[N],to[N],ed[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    ed[++idk]=x;<br>    to[idk]=v;<br>    ne[idk]=hd[u];<br>    hd[u]=idk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> be,<span class="hljs-type">int</span> en)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-type">bool</span> inq[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(be);<br>    dis[be]=<span class="hljs-number">0</span>;<br>    inq[be]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> now=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        inq[now]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//不可以加“剪枝”，因为有负环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[now];i;i=ne[i])&#123;<br>            <span class="hljs-keyword">if</span>(dis[to[i]]&gt;dis[now]+ed[i])&#123;<br>                dis[to[i]]=dis[now]+ed[i];<br>                <span class="hljs-keyword">if</span>(!inq[to[i]])&#123;<br>                    q.<span class="hljs-built_in">push</span>(to[i]);<br>                    inq[to[i]]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[en]==<span class="hljs-number">0x3f3f3f3f</span>)cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dis[en];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-built_in">merge</span>(x,y,z);<br>    &#125;<br>    <span class="hljs-built_in">spfa</span>(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断负环-1"><a href="#判断负环-1" class="headerlink" title="判断负环"></a>判断负环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1.5e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y,z;<br><span class="hljs-type">int</span> dis[N],cnt[N];<br><br><span class="hljs-type">int</span> idk;<br><span class="hljs-type">int</span> hd[N],ne[N],to[N],ed[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    ed[++idk]=x;<br>    to[idk]=v;<br>    ne[idk]=hd[u];<br>    hd[u]=idk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">bool</span> inq[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        cnt[i]=<span class="hljs-number">1</span>;<br>        inq[i]=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> now=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        inq[now]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[now];i;i=ne[i])&#123;<br>            <span class="hljs-keyword">if</span>(dis[to[i]]&gt;dis[now]+ed[i])&#123;<br>                dis[to[i]]=dis[now]+ed[i];<br>                cnt[to[i]]=cnt[now]<span class="hljs-number">+1</span>;<br>                <span class="hljs-keyword">if</span>(cnt[now]&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(!inq[to[i]])&#123;<br>                    q.<span class="hljs-built_in">push</span>(to[i]);<br>                    inq[to[i]]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-built_in">merge</span>(x,y,z);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>())cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>SPFA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Bellman-Ford贝尔曼弗德</title>
    <link href="/2024/08/03/Bellman-Ford/"/>
    <url>/2024/08/03/Bellman-Ford/</url>
    
    <content type="html"><![CDATA[<h1 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h1><p>常用于在有负权边的有向<strong>无环</strong>图中进行最短路判断。</p><p>要是有负权回路就没有结果了（或结果是负无穷）。解释：每转一圈距离就减一点，那我转啊转啊转啊转啊……然后就不出来了(～￣▽￣)～</p><p>事实上用<del>死了的</del>SPFA更好o(<em>￣︶￣</em>)o</p><p><strong>因此，事实上，一般用BELLMAN-FORD的都是有边数长度限制的题目，具体会在世纪意义中说明。</strong></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>重复执行n次：<br>遍历所有边，尝试更新每个边指向点的dis。（松弛操作）</p><p>啊对了每次遍历记得用上一次操作的结果来操作，不然会发生串联（本来要走两步的，但因为先后遍历了相邻两条边，导致一步之内走了两步）<br>。</p><p>。</p><p>对就没了(^▽^)</p><h2 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h2><p>迭代第k次，dis里存的是经过不超过k条边能到达的最短距离。</p><p>因此，可以求有最大边数限制的最短路问题，并且有负环也无所谓。</p><p>同时，它还可以判断是否存在负环：</p><p>若迭代第n次，还有点被更新，说明图中存在一条<strong>长度大于等于n的边</strong>，但一共只有n个点，所以一定有<strong>至少两个点被走了两次</strong>，所以存在环。又因为可以更新，所以这个环是<strong>负环</strong>。</p><p><em>然鹅一般找负环都是用SPFA做hh</em></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>由于负权最短路一般都给SPFA实现去了，这就来一道只能用贝尔曼弗德的题吧。</p><p><a href="https://www.acwing.com/problem/content/855/">AcWing853-有边数限制的最短路</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>,M=<span class="hljs-number">1e4</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> x,y,z;<br>&#125;es[M];<br><br><span class="hljs-type">int</span> n,k,m;<br><span class="hljs-type">int</span> dis[N],lis[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;t&lt;k;t++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)lis[i]=dis[i];<span class="hljs-comment">//记录上一次的结果防止串联</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            dis[es[i].y]=<span class="hljs-built_in">min</span>(dis[es[i].y],lis[es[i].x]+es[i].z);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[n]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>)cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>;<span class="hljs-comment">//不能写等于正无穷，因为负权边两侧正无穷能更新对方</span><br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dis[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;es[i].x&gt;&gt;es[i].y&gt;&gt;es[i].z;<br>    &#125;<br>    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>Bellman-Ford</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Dijkstra(HeapOptimized)迪杰斯特拉（堆优化）</title>
    <link href="/2024/08/03/Dijkstra-HeapOptimized/"/>
    <url>/2024/08/03/Dijkstra-HeapOptimized/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>其实就是用堆来优化Dijkstra算法（废话）。由于O(logm)（STL）与O(logn)（手写）为同一数量级，所以还是推荐直接用STL里的优先队列了。</p><p>其实就是优化了找当前距离最短的点的过程嘛。</p><p>由于是稀疏图，所以要用链式前向星做了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>事实上这种优化算法往往比朴素版更常见~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1.5e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y,z;<br><br><span class="hljs-type">int</span> idk;<br><span class="hljs-type">int</span> hd[N],ne[N],to[N],ed[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    ed[++idk]=x;<br>    to[idk]=v;<br>    ne[idk]=hd[u];<br>    hd[u]=idk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> be,<span class="hljs-type">int</span> en)</span></span>&#123;<br>    <span class="hljs-type">int</span> dis[N];<br>    <span class="hljs-type">bool</span> fns[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq;<br>    dis[be]=<span class="hljs-number">0</span>;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,be&#125;);<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">auto</span> tp=pq.<span class="hljs-built_in">top</span>();pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> ds=tp.first,dt=tp.second;<br>        <span class="hljs-keyword">if</span>(fns[dt])<span class="hljs-keyword">continue</span>;<br>        fns[dt]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(dt==en)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[dt];i;i=ne[i])&#123;<br>            <span class="hljs-keyword">if</span>(dis[to[i]]&gt;dis[dt]+ed[i])&#123;<br>                dis[to[i]]=dis[dt]+ed[i];<br>                pq.<span class="hljs-built_in">push</span>(&#123;dis[to[i]],to[i]&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[en]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dis[en]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        <span class="hljs-built_in">merge</span>(x,y,z);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">dij</span>(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>堆</tag>
      
      <tag>最短路</tag>
      
      <tag>Dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Dijkstra(Plain)迪杰斯特拉（朴素版）</title>
    <link href="/2024/08/03/Dijkstra-Plain/"/>
    <url>/2024/08/03/Dijkstra-Plain/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>与之前不同的是，图论的问题，重实现，而不重原理，所以这几篇博客会重点记录实现部分。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li>初始化：设立一个集合S（空）储存所有已确定最短距离的点，并设立距离dis数组，除了起点设为0外，其他点都设为正无穷。</li><li>在所有点中，找一个不在S里并且dis最小的点t</li><li>把t加入集合S，并且更新所有与之相连的点的距离。</li><li>重复执行2、3步直到每个点都加入集合S</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><em>update 2024&#x2F;8&#x2F;3: 新打了一份代码，在老代码下面，别急着走啊( •̀ ω •́ )✧</em></p><p>本来打算打一份邻接表&#x2F;链式前向星，但只找到了邻接矩阵的代码，反正没差多少，就写了吧。</p><p>注：赶时间，所以只能交一份陈年老代码，马蜂混乱(～￣▽￣)～</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,p,k,a,b,l;<br><span class="hljs-type">int</span> sz[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<br><span class="hljs-type">int</span> dis[<span class="hljs-number">1005</span>],vis[<span class="hljs-number">1005</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;p;<br>    <span class="hljs-built_in">memset</span>(sz,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(sz));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;l;<br>        <span class="hljs-keyword">if</span>(sz[a][b]!=<span class="hljs-number">-1</span>)sz[a][b]=<span class="hljs-built_in">min</span>(sz[a][b],l);<br>        <span class="hljs-keyword">else</span> sz[a][b]=l;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)dis[i]=INT_MAX;<br>    dis[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-type">int</span> mn=INT_MAX,mi=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(dis[i]&lt;mn&amp;&amp;!vis[i])&#123;<br>                mn=dis[i];<br>                mi=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!mi)<span class="hljs-keyword">break</span>;<br>        vis[mi]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(sz[mi][i]!=<span class="hljs-number">-1</span>&amp;&amp;dis[mi]+sz[mi][i]&lt;dis[i]&amp;&amp;!vis[i])&#123;<br>                dis[i]=dis[mi]+sz[mi][i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[n]==INT_MAX)&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;-1&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>    cout&lt;&lt;dis[n];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>新打了一份，照样是邻接矩阵，但是码风好看多了~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">505</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> g[N][N];<br><span class="hljs-type">int</span> x,y,z;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> be,<span class="hljs-type">int</span> en)</span></span>&#123;<br>    <span class="hljs-type">bool</span> fns[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-type">int</span> dis[N];<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    dis[be]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> mi=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(!fns[j]&amp;&amp;(mi==<span class="hljs-number">-1</span>||dis[j]&lt;dis[mi]))mi=j;<br>        &#125;<br>        fns[mi]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(mi==en)<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            dis[j]=<span class="hljs-built_in">min</span>(dis[j],dis[mi]+g[mi][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dis[en]==<span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dis[en];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>        g[x][y]=<span class="hljs-built_in">min</span>(g[x][y],z);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">dij</span>(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>Dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Shortest_Circuit_Problem(General)最短路问题总概</title>
    <link href="/2024/08/03/Shortest-Circuit-Problem-General/"/>
    <url>/2024/08/03/Shortest-Circuit-Problem-General/</url>
    
    <content type="html"><![CDATA[<p>#前言<br>本篇博客主要是总概整个最短路问题的算法一览，并不包括每个算法解析，如有需要，请看左边侧边栏的同分类下文章，毕竟也不多，自行寻找，谢谢。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>最短路问题就是求从某点到某点的最短距离。</p><p>源点就是起点，汇点就是终点。</p><h1 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h1><h2 id="边权全为正"><a href="#边权全为正" class="headerlink" title="边权全为正"></a>边权全为正</h2><h3 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h3><p>时间复杂度是O(n<sup>2</sup>)。故多用于稠密图。</p><h3 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h3><p>使用堆优化Dijkstra算法，时间复杂度O(mlogn)。故多用于稀疏图。</p><h2 id="存在负权边"><a href="#存在负权边" class="headerlink" title="存在负权边"></a>存在负权边</h2><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>时间复杂度O(nm)</p><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p><del>关于SPFA，它死了</del></p><p>时间复杂度一般O(m)，最坏O(nm)。</p><h1 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h1><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>时间复杂度O(n<sup>3</sup>)。</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Topo_Sort拓扑排序</title>
    <link href="/2024/08/03/Topo-Sort/"/>
    <url>/2024/08/03/Topo-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>拓扑排序，就是对图中的点进行排序。</p><p>排序方式如下：</p><p>对于每一个点，它指向的点都排在它后面，指向它的点都排在它前面。</p><p>所以，图只能是有向图，还得是<strong>有向无环图</strong>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>记录每一个点的入度，把入度为0的点加入队列，然后BFS一遍，每遍历一个点，就把它“删掉”，使其所有相邻点入度减一，然后再把入度为0的点加入队列。</p><p>无须用到vis数组的证明：如果重复遇到同一个点，则说明指向这个点的边不止一条，但是只有当入度为0时才会把这个点加入队列，所以这个点只会被遍历一次。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>由于这是个算法，所以模板不是很固定，所以就直接上模板题吧。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/850/">AcWing848-有向图的拓扑排序</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-type">int</span> dg[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><br><span class="hljs-type">int</span> idk;<br><span class="hljs-type">int</span> hd[N],to[N],ne[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    to[++idk]=b;<br>    ne[idk]=hd[a];<br>    hd[a]=idk;<br>    dg[b]++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> fns=<span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(dg[i]==<span class="hljs-number">0</span>)q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> now=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>        vec.<span class="hljs-built_in">push_back</span>(now);<br>        fns++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[now];i;i=ne[i])&#123;<br>            dg[to[i]]--;<br>            <span class="hljs-keyword">if</span>(dg[to[i]]==<span class="hljs-number">0</span>)q.<span class="hljs-built_in">push</span>(to[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fns==n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-built_in">merge</span>(x,y);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">topo</span>())&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;vec.<span class="hljs-built_in">size</span>();i++)cout&lt;&lt;vec[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Storage_of_Graph图的存储</title>
    <link href="/2024/08/03/Storage-of-Graph/"/>
    <url>/2024/08/03/Storage-of-Graph/</url>
    
    <content type="html"><![CDATA[<h1 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h1><p>啊开个二维数组，然后a[i][j]表示i到j的边长。完事了。</p><h1 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h1><p>利用链表储存每个点的相邻节点。</p><h1 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h1><p>哈希中拉链法头插法也是用的这个。<br><a href="https://githarlem.github.io/2024/08/02/Hash-Table/">[编程笔记]-Hash_Table哈希表</a></p><p>记录每个节点的第一条边、每条边的边长、每条边指向的节点、每条边的下一条边（指把这个节点的所有边形成一种链式结构链接），然后就能遍历所有边了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>前面两个都太简单了，所以就直接上链式前向星的代码吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> x)</span></span>&#123;<br>ed[++idk]=x;<br>to[idk]=v;<br>ne[idk]=hd[u];<br>hd[u]=idk;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>树论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-BFS广度优先搜索</title>
    <link href="/2024/08/03/BFS/"/>
    <url>/2024/08/03/BFS/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>BFS(Breadth First Search)，广度优先搜索，典中典，重中重。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>一般用来在图、树中进行搜索。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>过程可视作一棵树，每次把所有子节点都搜一遍，然后把所有子节点加入待搜索的队列中，排着队一个一个搜，每一个又把所有子节点加入队中……</p><p>其实就是一层一层地搜索~</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>一般用队列来模拟，需要O(2<sup>h</sup>)的空间。同时，由于BFS算法的性质，它可以用来解决“最短路”问题。</p><p><em>实现最短路：第一次搜到的点肯定是离根节点最近的路径搜到的点。</em></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>本来不想写的，但是想到DFS那里我就鸽了所以这里不得不写了hh</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> be, <span class="hljs-type">int</span> en)</span></span>&#123;<br><span class="hljs-type">int</span> d[N];queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(d));<br>d[be]=<span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(d);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-comment">//取出点</span><br><span class="hljs-comment">//找相邻点</span><br><span class="hljs-comment">//如果是终点就直接退出了。</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为啥不打完呢……因为BFS的写法很多样，不唯一，所以给个思路就行了。</p><p>（归根结底就是这个蒟蒻太懒了hhh）</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>就来一道毒瘤吧</p><p><a href="https://www.acwing.com/problem/content/847/">AcWing845-八数码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> a;<br>string str=<span class="hljs-string">&quot;&quot;</span>;<br>string en=<span class="hljs-string">&quot;12345678x&quot;</span>;<br><br>unordered_map&lt;string,<span class="hljs-type">int</span>&gt; d;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string be)</span></span>&#123;<br>    queue&lt;string&gt; q;<br>    q.<span class="hljs-built_in">push</span>(be);<br>    d[be]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        string now=q.<span class="hljs-built_in">front</span>(),tstr;q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(now==en)<span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> t=now.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;x&#x27;</span>);<br>        <span class="hljs-type">int</span> tx=t/<span class="hljs-number">3</span>,ty=t%<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nx=tx+dx[i],ny=ty+dy[i];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;=nx&amp;&amp;nx&lt;<span class="hljs-number">3</span>&amp;&amp;<span class="hljs-number">0</span>&lt;=ny&amp;&amp;ny&lt;<span class="hljs-number">3</span>)&#123;<br>                tstr=now;<br>                <span class="hljs-built_in">swap</span>(tstr[t],tstr[nx*<span class="hljs-number">3</span>+ny]);<br>                <span class="hljs-keyword">if</span>(!d.<span class="hljs-built_in">count</span>(tstr))&#123;<br>                    d[tstr]=d[now]<span class="hljs-number">+1</span>;<br>                    q.<span class="hljs-built_in">push</span>(tstr);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>        cin&gt;&gt;a;<br>        str+=a;<br>    &#125;<br>    <span class="hljs-built_in">bfs</span>(str);<br>    <span class="hljs-keyword">if</span>(!d.<span class="hljs-built_in">count</span>(en))cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;d[en];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>树论</tag>
      
      <tag>BFS</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-DFS深度优先搜索</title>
    <link href="/2024/08/03/DFS/"/>
    <url>/2024/08/03/DFS/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>DFS(Deep First Search)，深度优先搜索，典中典，重中重。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>一般用来在图、树中进行搜索。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>过程可视作一棵树，每次向着子节点搜索，搜到叶节点就回溯，然后搜下一个子节点，直到把子节点搜完了就接着回溯。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>一般用栈来模拟，需要O(h)的空间</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>就是从子节点回到父节点</p><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>跳过已经遍历过的点减少时间复杂度。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>这个太简单了，过(～￣▽￣)～</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>这个嘛……说句实话不是很常用，而且和BFS的代码基本没有区别，所以就不写了。</p><p>挂个BFS，需要者自取：</p><p><a href="https://githarlem.github.io/2024/08/03/BFS/">[编程笔记]-BFS广度优先搜索</a></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>这么典的算法，肯定要配一个超典的题型~</p><p><strong>n皇后问题</strong></p><p><a href="https://www.acwing.com/problem/content/submission/845/">AcWing843-n皇后问题</a></p><h2 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h2><p><em>为啥先讲进阶版？您是先学会用打火机还是先学会钻木取火？</em></p><p>由于每一行都只有一个皇后，所以遍历每一行就行了，整体思路根全排列一样。</p><p>给每个竖列、对角线都设立一个对应判断值，然后直接套板子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> use[N];<br><span class="hljs-type">bool</span> vis[N]=&#123;<span class="hljs-literal">false</span>&#125;,deg[N*<span class="hljs-number">2</span>]=&#123;<span class="hljs-literal">false</span>&#125;,fdg[N*<span class="hljs-number">2</span>]=&#123;<span class="hljs-literal">false</span>&#125;;<span class="hljs-comment">//deg-&gt;右倾对角线右侧顶点；fdg-&gt;左倾对角线右侧顶点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(now==n<span class="hljs-number">+1</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(use[i]==j)cout&lt;&lt;<span class="hljs-string">&#x27;Q&#x27;</span>;<br>                <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>            cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;!deg[n-now+i]&amp;&amp;!fdg[now+i])&#123;<br>            use[now]=i;<br>            vis[i]=deg[n-now+i]=fdg[now+i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(now<span class="hljs-number">+1</span>);<br>            vis[i]=deg[n-now+i]=fdg[now+i]=<span class="hljs-literal">false</span>;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h2><p>暴力循环每一个格子——选or不选……选or不选……</p><p>然后每n<sup>2</sup>次对一下答案。</p><p>听起来就暴力极了。(^▽^)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//反正判断行列跟进阶版一样，然后思路又简单到爆炸，所以想必就不用我这个蒟蒻打了(^▽^)</span><br></code></pre></td></tr></table></figure><h1 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h1><p>毕竟是图论问题，还是来一道和图论关系大的吧。<br><a href="https://www.acwing.com/problem/content/848/">AcWing846-树的重心</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> idk;<br><span class="hljs-type">int</span> ed[N*<span class="hljs-number">2</span>],to[N*<span class="hljs-number">2</span>],ne[N*<span class="hljs-number">2</span>],hd[N];<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a,b;<br><span class="hljs-type">int</span> vis[N]=&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> v=<span class="hljs-number">1</span>)</span></span>&#123;<br>    ed[++idk]=v;<br>    to[idk]=y;<br>    ne[idk]=hd[x];<br>    hd[x]=idk;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfsize</span><span class="hljs-params">(<span class="hljs-type">int</span> now)</span></span>&#123;<br>    vis[now]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,sum=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[now];i;i=ne[i])&#123;<br>        <span class="hljs-keyword">if</span>(!vis[to[i]])&#123;<br>            <span class="hljs-type">int</span> t=<span class="hljs-built_in">dfsize</span>(to[i]);<br>            res=<span class="hljs-built_in">max</span>(res,t);<br>            sum+=t;<br>        &#125;<br>    &#125;<br>    res=<span class="hljs-built_in">max</span>(res,n-sum);<br>    ans=<span class="hljs-built_in">min</span>(ans,res);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">merge</span>(a,b);<br>        <span class="hljs-built_in">merge</span>(b,a);<br>    &#125;<br>    <span class="hljs-built_in">dfsize</span>(n);<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>图论树论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>图论</tag>
      
      <tag>树论</tag>
      
      <tag>搜索</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-STLs(STL大整合)</title>
    <link href="/2024/08/03/STLs/"/>
    <url>/2024/08/03/STLs/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>手打STL毕竟只是锦上添花，STL才是雪中送炭。</p><p>所以，来一篇STL<del>大杂烩</del>大整合！</p><p>注意，这里只整理了常用函数，并不是全部函数！</p><h1 id="VECTOR"><a href="#VECTOR" class="headerlink" title="VECTOR"></a>VECTOR</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>是一种动态数组，运用到倍增的思想。</p><p>按字典序排序。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><em>因为申请空间耗时与空间大小无关、与申请次数有关——</em></p><p>所以vector会倍增申请空间o(<em>￣︶￣</em>)o</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>push_back()</code></td><td align="center">在队尾加入元素</td><td align="left"><code>vec.push_back(加入元素)</code></td></tr><tr><td align="center"><code>pop_back()</code></td><td align="center">在队尾删除元素</td><td align="left"><code>vec.pop_back()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">判断是否为空</td><td align="left"><code>vec.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>vec.clear()</code></td></tr><tr><td align="center"><code>size()</code></td><td align="center">元素个数</td><td align="left"><code>vec.size()</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查找元素位置，否则返回队尾</td><td align="left"><code>find(起始位置, 终止位置, 查找元素)</code></td></tr><tr><td align="center"><code>front()</code></td><td align="center">返回队头元素</td><td align="left"><code>vec.front()</code></td></tr><tr><td align="center"><code>back()</code></td><td align="center">返回队尾元素</td><td align="left"><code>vec.back()</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回队头迭代器</td><td align="left"><code>vec.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回队尾迭代器（最后元素的后一个元素）</td><td align="left"><code>vec.end()</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除指定元素</td><td align="left"><code>vec.erase(迭代器)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除指定区间（左闭右开）元素</td><td align="left"><code>vec.erase(开始迭代器, 结束迭代器)</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center">随机选址</td><td align="left"><code>vec[]</code></td></tr></tbody></table><h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><ul><li><code>vector&lt;TYPE&gt; a</code>，定义一个存储TYPE类型变量vector a。</li><li><code>vector&lt;TYPE&gt; a(n)</code>，定义一个大小为n的存储TYPE类型变量vector a。</li><li><code>vector&lt;TYPE&gt; a(n, x)</code>，定义一个大小为n的存储TYPE类型变量且初始值全为x的vector a。</li><li><code>vector&lt;TYPE&gt; a[n]</code>，定义n个存储TYPE类型变量vector a。</li></ul><h1 id="PAIR"><a href="#PAIR" class="headerlink" title="PAIR"></a>PAIR</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>两个元素（不限种类）的结合体。</p><p>有点就是自带比较函数，先比第一个再比第二个（各自按字典序排序），可以很方便地<code>sort()</code>。</p><h2 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>first</code></td><td align="center">第一元素</td><td align="left"><code>p.first</code></td></tr><tr><td align="center"><code>second</code></td><td align="center">第二元素</td><td align="left"><code>p.second</code></td></tr></tbody></table><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p><code>pair&lt;T1, T2&gt; p</code>，定义一个两个元素分别是T1类型和T2类型的pair p。</p><ul><li>make_pair(a, b)，返回一个由a和b构成的pair。</li><li>{a, b}，返回一个由a和b构成的pair。（c++11专用）</li></ul><h1 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>字符串。</p><h2 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>substr()</code></td><td align="center">截取子串</td><td align="left"><code>str.substr(起始下标, 截取长度)</code></td></tr><tr><td align="center"><code>c_str()</code></td><td align="center">转换为c语言字符串（支持scanf）</td><td align="left"><code>str.c_str()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">判断是否为空</td><td align="left"><code>str.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>str.clear()</code></td></tr><tr><td align="center"><code>size()</code></td><td align="center">字符串长度</td><td align="left"><code>str.size()</code></td></tr><tr><td align="center"><code>length()</code></td><td align="center">字符串长度</td><td align="left"><code>str.length()</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查询字符位置</td><td align="left"><code>str.find(查询字符)</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center">随机选址</td><td align="left"><code>str[]</code></td></tr></tbody></table><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h4><p>如果截取长度超出字符串长度，或没有设定截取长度，默认截取至结尾。</p><h4 id="c-str"><a href="#c-str" class="headerlink" title="c_str()"></a>c_str()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,a.<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><code>string a</code>，定义一个string a。</li><li><code>string a = str</code>，定义一个内容为str的string a。</li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li>a+&#x3D;b，在a末尾加上b（string）。</li><li>a+&#x3D;b，在a末尾加上b（char）。</li></ul><h1 id="QUEUE"><a href="#QUEUE" class="headerlink" title="QUEUE"></a>QUEUE</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>队列。</p><h2 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>push()</code></td><td align="center">入队</td><td align="left"><code>q.push(入队元素)</code></td></tr><tr><td align="center"><code>pop()</code></td><td align="center">队头出队</td><td align="left"><code>q.pop()</code></td></tr><tr><td align="center"><code>front()</code></td><td align="center">获取队头</td><td align="left"><code>q.front()</code></td></tr><tr><td align="center"><code>back()</code></td><td align="center">获取队尾</td><td align="left"><code>q.back()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">判断是否为空</td><td align="left"><code>q.empty()</code></td></tr><tr><td align="center"><code>size()</code></td><td align="center">队列元素个数</td><td align="left"><code>q.size()</code></td></tr></tbody></table><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><p>直接重开一个队列就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">q=<span class="hljs-built_in">queue</span>&lt;TYPE&gt;();<br></code></pre></td></tr></table></figure><h1 id="PRIORITY-QUEUE"><a href="#PRIORITY-QUEUE" class="headerlink" title="PRIORITY_QUEUE"></a>PRIORITY_QUEUE</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>优先队列（堆），默认大根堆</p><p><strong>比较常用</strong></p><h2 id="常用函数-4"><a href="#常用函数-4" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>push()</code></td><td align="center">入堆</td><td align="left"><code>pq.push(入堆元素)</code></td></tr><tr><td align="center"><code>top()</code></td><td align="center">获取堆顶</td><td align="left"><code>pq.top()</code></td></tr><tr><td align="center"><code>pop()</code></td><td align="center">堆顶出堆</td><td align="left"><code>pq.pop()</code></td></tr></tbody></table><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><h3 id="实现小根堆"><a href="#实现小根堆" class="headerlink" title="实现小根堆"></a>实现小根堆</h3><ul><li>插入-x，最后输出的时候取反。</li><li><code>priority_queue&lt;TYPE, vector&lt;TYPE&gt;, greater&lt;TYPE&gt; &gt;</code></li></ul><h1 id="STACK"><a href="#STACK" class="headerlink" title="STACK"></a>STACK</h1><h2 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h2><p>栈</p><h2 id="常用函数-5"><a href="#常用函数-5" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>push()</code></td><td align="center">入栈</td><td align="left"><code>st.push(入栈元素)</code></td></tr><tr><td align="center"><code>top()</code></td><td align="center">获取栈顶</td><td align="left"><code>st.top()</code></td></tr><tr><td align="center"><code>pop()</code></td><td align="center">栈顶出栈</td><td align="left"><code>st.pop()</code></td></tr><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>st.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>st.empty()</code></td></tr></tbody></table><h1 id="DEQUE"><a href="#DEQUE" class="headerlink" title="DEQUE"></a>DEQUE</h1><h2 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h2><p>双端队列</p><p><del>很牛逼哒</del></p><p><em>效率低的令人发指，慢了好几倍~</em></p><h2 id="常用函数-6"><a href="#常用函数-6" class="headerlink" title="常用函数"></a>常用函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>dq.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>dq.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>dq.clear()</code></td></tr><tr><td align="center"><code>front()</code></td><td align="center">获取队头</td><td align="left"><code>dq.front()</code></td></tr><tr><td align="center"><code>back()</code></td><td align="center">获取队尾</td><td align="left"><code>dq.back()</code></td></tr><tr><td align="center"><code>push_front()</code></td><td align="center">在队头加入元素</td><td align="left"><code>dq.push_front(加入元素)</code></td></tr><tr><td align="center"><code>pop_front()</code></td><td align="center">在队头删除元素</td><td align="left"><code>dq.pop_front()</code></td></tr><tr><td align="center"><code>push_back()</code></td><td align="center">在队尾加入元素</td><td align="left"><code>dq.push_back(加入元素)</code></td></tr><tr><td align="center"><code>pop_back()</code></td><td align="center">在队尾删除元素</td><td align="left"><code>dq.pop_back()</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center">随机选址</td><td align="left"><code>dq[]</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回队头迭代器</td><td align="left"><code>dq.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回队尾迭代器（最后元素的后一个元素）</td><td align="left"><code>dq.end()</code></td></tr></tbody></table><h1 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h1><h2 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>基于平衡二叉树（红黑树），动态维护有序序列。</p><p><code>set</code>不能有重复元素，否则会被忽略掉。<br>而<code>multiset</code>可以。</p><h3 id="常用函数-7"><a href="#常用函数-7" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>s.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>s.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>s.clear()</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回第一个迭代器</td><td align="left"><code>s.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回最后的迭代器（最后元素的后一个元素）</td><td align="left"><code>s.end()</code></td></tr><tr><td align="center"><code>insert()</code></td><td align="center">插入元素</td><td align="left"><code>s.insert(插入元素)</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查找元素，若无则返回end迭代器</td><td align="left"><code>s.find(查找元素)</code></td></tr><tr><td align="center"><code>count()</code></td><td align="center">返回某一元素个数</td><td align="left"><code>s.count(查找元素)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除所有对应值的元素</td><td align="left"><code>s.erase(删除值)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应迭代器的元素</td><td align="left"><code>s.erase(删除迭代器)</code></td></tr><tr><td align="center"><code>lower_bound()</code></td><td align="center">返回大于等于标准值的最小数迭代器</td><td align="left"><code>s.lower_bound(标准值)</code></td></tr><tr><td align="center"><code>upper_bound()</code></td><td align="center">返回大于标准值的最小数迭代器</td><td align="left"><code>s.upper_bound(标准值)</code></td></tr></tbody></table><h3 id="定义方式-1"><a href="#定义方式-1" class="headerlink" title="定义方式"></a>定义方式</h3><p><code>set&lt;TYPE&gt; s</code>，定义一个存储TYPE类型变量set s。<br><code>multiset&lt;TYPE&gt; ms</code>，定义一个存储TYPE类型变量multiset ms。</p><h3 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h3><p>迭代器可以++&#x2F;–，前移后移。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>绝大部分O(logn)</p><h2 id="unordered-set-unordered-muiltiset"><a href="#unordered-set-unordered-muiltiset" class="headerlink" title="unordered_set&#x2F;unordered_muiltiset"></a>unordered_set&#x2F;unordered_muiltiset</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>基于哈希表实现</p><h3 id="常用函数-8"><a href="#常用函数-8" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>us.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>us.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>us.clear()</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回第一个迭代器</td><td align="left"><code>us.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回最后的迭代器（最后元素的后一个元素）</td><td align="left"><code>us.end()</code></td></tr><tr><td align="center"><code>insert()</code></td><td align="center">插入元素</td><td align="left"><code>us.insert(插入元素)</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查找元素，若无则返回end迭代器</td><td align="left"><code>us.find(查找元素)</code></td></tr><tr><td align="center"><code>count()</code></td><td align="center">返回某一元素个数</td><td align="left"><code>us.count(查找元素)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除所有对应值的元素</td><td align="left"><code>us.erase(删除值)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应迭代器的元素</td><td align="left"><code>us.erase(删除迭代器)</code></td></tr></tbody></table><h3 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h3><p>迭代器<strong>不</strong>可以++&#x2F;–，前移后移。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>增删改查O(1)</p><h1 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h1><h2 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>基于平衡二叉树（红黑树），动态维护有序序列。</p><h3 id="常用函数-9"><a href="#常用函数-9" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>m.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>m.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>m.clear()</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回第一个迭代器</td><td align="left"><code>m.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回最后的迭代器（最后元素的后一个元素）</td><td align="left"><code>m.end()</code></td></tr><tr><td align="center"><code>insert()</code></td><td align="center">插入一对元素</td><td align="left"><code>m.insert(插入pair)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应对元素</td><td align="left"><code>m.erase(删除pair)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应迭代器元素</td><td align="left"><code>m.erase(删除迭代器)</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查找要求键元素迭代器，若无则返回end迭代器</td><td align="left"><code>m.find(要求查找键)</code></td></tr><tr><td align="center"><code>count()</code></td><td align="center">返回某一元素个数</td><td align="left"><code>m.count(查找元素)</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center">像使用数组一样使用（查找、修改）</td><td align="left"><code>m[]</code></td></tr><tr><td align="center"><code>lower_bound()</code></td><td align="center">返回大于等于标准值的最小数迭代器</td><td align="left"><code>m.lower_bound(标准值)</code></td></tr><tr><td align="center"><code>upper_bound()</code></td><td align="center">返回大于标准值的最小数迭代器</td><td align="left"><code>m.upper_bound(标准值)</code></td></tr></tbody></table><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>[]</code>的时间复杂度是O(logn)的。</p><h3 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a>操作</h3><p>迭代器可以++&#x2F;–，前移后移。</p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>绝大部分O(logn)</p><h2 id="unordered-map-unordered-multimap"><a href="#unordered-map-unordered-multimap" class="headerlink" title="unordered_map&#x2F;unordered_multimap"></a>unordered_map&#x2F;unordered_multimap</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>基于哈希表实现</p><h3 id="常用函数-10"><a href="#常用函数-10" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>size()</code></td><td align="center">获取元素个数</td><td align="left"><code>um.size()</code></td></tr><tr><td align="center"><code>empty()</code></td><td align="center">是否为空</td><td align="left"><code>um.empty()</code></td></tr><tr><td align="center"><code>clear()</code></td><td align="center">清空</td><td align="left"><code>um.clear()</code></td></tr><tr><td align="center"><code>begin()</code></td><td align="center">返回第一个迭代器</td><td align="left"><code>um.begin()</code></td></tr><tr><td align="center"><code>end()</code></td><td align="center">返回最后的迭代器（最后元素的后一个元素）</td><td align="left"><code>um.end()</code></td></tr><tr><td align="center"><code>insert()</code></td><td align="center">插入一对元素</td><td align="left"><code>um.insert(插入pair)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应对元素</td><td align="left"><code>um.erase(删除pair)</code></td></tr><tr><td align="center"><code>erase()</code></td><td align="center">删除对应迭代器元素</td><td align="left"><code>m.erase(删除迭代器)</code></td></tr><tr><td align="center"><code>find()</code></td><td align="center">查找要求键元素迭代器，若无则返回end迭代器</td><td align="left"><code>um.find(要求查找键)</code></td></tr><tr><td align="center"><code>count()</code></td><td align="center">返回某一元素个数</td><td align="left"><code>um.count(查找元素)</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center">像使用数组一样使用（查找、修改）</td><td align="left"><code>um[]</code></td></tr></tbody></table><h3 id="操作-6"><a href="#操作-6" class="headerlink" title="操作"></a>操作</h3><p>迭代器<strong>不</strong>可以++&#x2F;–，前移后移。</p><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>增删改查O(1)</p><h1 id="BITSET"><a href="#BITSET" class="headerlink" title="BITSET"></a>BITSET</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>压位</p><p>bool数组一个元素占8位，而bitset一个元素只占1位，节省了八倍内存。</p><h2 id="定义方式-2"><a href="#定义方式-2" class="headerlink" title="定义方式"></a>定义方式</h2><p><code>bitset&lt;n&gt; bs</code>，定义一个存储n个bool的bitset bs。</p><h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">函数作用</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center"><code>count()</code></td><td align="center">获取1的个数</td><td align="left"><code>bs.count()</code></td></tr><tr><td align="center"><code>any()</code></td><td align="center">判断是否有1</td><td align="left"><code>bs.any()</code></td></tr><tr><td align="center"><code>none()</code></td><td align="center">判断是否全是0</td><td align="left"><code>bs.none()</code></td></tr><tr><td align="center"><code>set()</code></td><td align="center">把所有位设成1</td><td align="left"><code>bs.set()</code></td></tr><tr><td align="center"><code>set()</code></td><td align="center">把要求位置设成要求值</td><td align="left"><code>bs.set(要求位置, 要求值)</code></td></tr><tr><td align="center"><code>reset()</code></td><td align="center">把所有位设成0</td><td align="left"><code>bs.reset()</code></td></tr><tr><td align="center"><code>flip()</code></td><td align="center">把所有位取反</td><td align="left"><code>bs.flip()</code></td></tr><tr><td align="center"><code>flip()</code></td><td align="center">把指定位取反</td><td align="left"><code>bs.flip(指定位)</code></td></tr></tbody></table><h2 id="操作-7"><a href="#操作-7" class="headerlink" title="操作"></a>操作</h2><p>支持所有位运算：<code>&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;</code></p><p>支持<code>==</code>和<code>!=</code></p><p>支持<code>[]</code>看某一位</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-String_Hash字符串哈希</title>
    <link href="/2024/08/03/String-Hash/"/>
    <url>/2024/08/03/String-Hash/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这边首先推荐有需要滴去先瞅眼哈希表。<br><a href="https://githarlem.github.io/2024/08/02/Hash-Table/">“[编程笔记]-Hash_Table哈希表”</a></p><p>（半夜写的，可能有点癫嘿嘿嘿）</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>字符串哈希，就是对字符串进行哈希，达到快速储存和查询的目的。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="求HASH"><a href="#求HASH" class="headerlink" title="求HASH"></a>求HASH</h2><p>这里要用到一种特殊的哈希方法：将字符串视作一个p进制数（p不一定，按题目要求来，一般就是所有可能出现的字符的个数，反正能让每个字符串独一无二就行），然后再对这个p进制数进行哈希操作。别的就一模一样了。</p><p><strong>WARNING: 一般情况下不要映射成0！否则会造成哈希冲突！</strong></p><p><strong>WARNING: <del>这个算法下我们强的可怕！</del>我们rp很nb！不考虑哈希冲突！</strong></p><p><strong>JINGYAN!!!: 当p取131或13331时，q（模）取2<sup>64</sup>时，在99.99%的情况下，都不会出现冲突。</strong></p><p><strong>生活小寄巧：可用<code>ull</code>储存所有哈希值，这样就不用取模了，溢出就相当于取模了哈哈哈。</strong></p><p><strong>所以就易如反掌瓮中捉鳖轻轻松松探囊取物——<code>h[i]=h[i-1]*p+str[i]</code></strong></p><hr><p>另外，这个方法有个<strong>小点</strong>可以注意一下：</p><p>如果我们求出了字符串每个前缀的hash值，就可以求出每个子串的hash值。</p><p>挂一个前缀和吧，<del>虽然应该没有人会需要它</del><a href="https://githarlem.github.io/2024/07/30/Partial-Sum/">“[编程笔记]-Partial_Sum前缀和”</a></p><p>公式：<code>h[r]-h[l]*p^(r-l+1)</code></p><p>推导：举个例子，一个是”GRAY”，一个是”GRAYGOO”，要想得到”GOO”，肯定要用”GRAYGOO”减去”GRAY”左移三位得到的”GRAY   “。<em>当然我更希望去个GOO留GRAY，但为了方便理解还是放弃了。</em></p><p>啊对了其实这个小点是一个重点但是我懒得改前面的内容了所以就在前面加个着重符号吧(╹ڡ╹ )</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>由于这算法本来是用来字符串匹配，但例题拿来子串匹配，不仅完美结合了原方法，还巧妙融合了前缀和问题（就是上面那个重点），所以就直接用这道<del>毒瘤</del>好题了。</p><p><a href="https://www.acwing.com/problem/content/843/">AcWing841-字符串哈希</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>,P=<span class="hljs-number">131</span>;<br><br><span class="hljs-type">int</span> n,m;<br>string str;<br>ull h[N],p[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;str;<br>    str=<span class="hljs-string">&#x27; &#x27;</span>+str;<br>    p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        p[i]=p[i<span class="hljs-number">-1</span>]*P;<br>        h[i]=h[i<span class="hljs-number">-1</span>]*P+str[i];<br>    &#125;<br>    <span class="hljs-type">int</span> l1,r1,l2,r2;<br>    ull h1,h2;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;<br>        h1=h[r1]-h[l1<span class="hljs-number">-1</span>]*p[r1-l1<span class="hljs-number">+1</span>];<br>        h2=h[r2]-h[l2<span class="hljs-number">-1</span>]*p[r2-l2<span class="hljs-number">+1</span>];<br>        cout&lt;&lt;(h1==h2?<span class="hljs-string">&quot;Yes\n&quot;</span>:<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1><p><em>再这么熬下去我就成国家一级保护废物了</em></p>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>哈希</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Hash_Table哈希表</title>
    <link href="/2024/08/02/Hash-Table/"/>
    <url>/2024/08/02/Hash-Table/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>通过哈希函数（自定义，一般是取模），把数据映射到哈希表上。</p><p>听不懂就对了，听得懂也没必要看原理了(～￣▽￣)～</p><p>当然，如果已经学过离散化的，理解起来可能方便些。</p><p>为了方便学习，这里挂一个离散化链接：<br><a href="https://githarlem.github.io/2024/07/31/Discretization/">“[编程笔记]-Discretization离散化”</a></p><p>顺便也挂一个字符串哈希吧，毕竟同根同源~<br><a href="https://githarlem.github.io/2024/08/03/String-Hash/">“[编程笔记]-String_Hash字符串哈希”</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>这点就讲讲哈希函数，为了减少哈希冲突，我们一般都会选择模一个质数。</p><h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><p>有两种方式：拉链法（或者挂链法之类的）和开放寻址法。</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>就是在哈希表上每一个节点后都拉一条链表，遇到冲突的直接插到链表后面，或者用类似链式前向星的方法插到表头。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>遇到冲突想办法找别的空位子坐下。经验表明，一般要开题目要求范围内的两到三倍。</p><p>需要注意的是，开放寻址法中，因为查询也是照着插入的方式一个一个找的，所以如果真的删除了元素的话，那么就会使查找过程异常，所以一般都是打个标记。（删除过程和查询过程一模一样hh）</p><p><em>y总の奇妙比喻belike: 就像澈硕找坑位一样，这个有人，欸<del>下一个，找到空的，欸</del>就你了！</em></p><h2 id="寻找"><a href="#寻找" class="headerlink" title="寻找"></a>寻找</h2><p>靠哈希函数找出当前值应该在的位置，然后挂链法就顺着链表找一遍，开放寻址法麻烦一点，一般暴力做法就是绕着找一圈。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="拉链法-1"><a href="#拉链法-1" class="headerlink" title="拉链法"></a>拉链法</h2><p>鉴于尾插法过于简单，这里使用头插法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> hd[N],ne[N],vl[N],idk;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>                hd[i]=<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> (x%N+N)%N;<span class="hljs-comment">//防负数</span><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            vl[++idk]=x;<br>            <span class="hljs-type">int</span> key=<span class="hljs-built_in">hash</span>(x);<br>            ne[idk]=hd[key];<br>            hd[key]=idk;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-type">int</span> key=<span class="hljs-built_in">hash</span>(x);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=hd[key];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>                <span class="hljs-keyword">if</span>(vl[i]==x)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;hs;<br></code></pre></td></tr></table></figure><h2 id="开放寻址法-1"><a href="#开放寻址法-1" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>本模板中无删除功能，如有需要请自行添加，因为和查找功能基本上没有区别，只需要再单开一个判断是否删除的数组就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hash</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> h[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(h));<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> (x%N+N)%N;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">hash</span>(x);<br>            <span class="hljs-keyword">while</span>(h[k]!=nb&amp;&amp;h[k]!=x)&#123;<br>                <span class="hljs-keyword">if</span>(++k==N)k=<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> k;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">find</span>(x);<br>            h[k]=x;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">find</span>(x);<br>            <span class="hljs-keyword">return</span> h[k]==x;<br>        &#125;<br>&#125;hs;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Heap堆</title>
    <link href="/2024/08/02/Heap/"/>
    <url>/2024/08/02/Heap/</url>
    
    <content type="html"><![CDATA[<h1 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h1><p>事实上，堆就是一棵完全二叉树。</p><p>在堆中，以小根堆为例，每个父节点总是小于等于子节点的。</p><p>所以根节点事实上就是最小值。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ol><li>插入一个数</li><li>求集合当中的最小值</li><li>删除最小值</li><li>删除任意元素（STL做不到）</li><li>修改任意元素（STL做不到）</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>利用一维数组实现，2<em>x是x左子节点，2</em>x+1是x右子节点。</p><h2 id="基操"><a href="#基操" class="headerlink" title="基操"></a>基操</h2><p>根有两个基本操作：上移和下移，就是把节点与父节点&#x2F;子节点互换以维护堆的单调性。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>先随便把元素存进去，然后对前n&#x2F;2个元素从后往前进行下移操作，就能完成初始化操作。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(n)。但这个证明有点复杂，就不在这里放出了。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>随便新建一个叶节点，然后执行上移操作。</p><h2 id="求最小值"><a href="#求最小值" class="headerlink" title="求最小值"></a>求最小值</h2><p>根节点啊。</p><h2 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h2><p>将根节点和最后一个节点互换一下，然后直接删掉尾节点（原根节点），最后下移操作维护。</p><p><em>y总的奇妙比喻：现在有一队人，直接杀队头肯定不方便，那么把队头队尾狸猫换太子，直接K掉队尾，神不知鬼不觉，最后维持下秩序就OK了Σ(っ °Д °;)っ</em></p><h2 id="删除任意元素"><a href="#删除任意元素" class="headerlink" title="删除任意元素"></a>删除任意元素</h2><p>和删除最小值一样，不过最后上移下移都要试一遍。</p><h2 id="修改任意元素"><a href="#修改任意元素" class="headerlink" title="修改任意元素"></a>修改任意元素</h2><p>同理，修改指定元素后，上移一遍<del>下移一遍</del>欸，好了（￣︶￣）</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>啊这个堆排序的话只需要获取最小值&amp;输出最小值就OK了，所以其实只会用到下移操作，所以<del>您也跟我一样够懒的话</del>只写下移函数就可以了。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>毕竟是树嘛，所以很快得出是O(logn)啦。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h2><p>还是给一道板子题吧：<br><a href="https://www.acwing.com/problem/content/840/">AcWing838-堆排序</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> now)</span></span>&#123;<br>    <span class="hljs-type">int</span> son=now;<br>    <span class="hljs-keyword">if</span>(now*<span class="hljs-number">2</span>&lt;=n&amp;&amp;a[now*<span class="hljs-number">2</span>]&lt;=a[son])son=now*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(now*<span class="hljs-number">2</span><span class="hljs-number">+1</span>&lt;=n&amp;&amp;a[now*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]&lt;=a[son])son=now*<span class="hljs-number">2</span><span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">if</span>(now!=son)&#123;<br>        <span class="hljs-built_in">swap</span>(a[now],a[son]);<br>        <span class="hljs-built_in">down</span>(son);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        <span class="hljs-built_in">down</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">heap_sort</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cout&lt;&lt;a[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">swap</span>(a[<span class="hljs-number">1</span>],a[n--]);<br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h2><p>注意，这个堆中还记录了插入结点的编号，所以在细节上硬控我半小时(ノへ￣、)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">heap</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> idk,n;<br>        <span class="hljs-type">int</span> h[N],ph[N],hp[N];<span class="hljs-comment">//ph是编号对应的下标，hp是下标对应的编号。</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            <span class="hljs-built_in">swap</span>(h[a],h[b]);<br>            <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>            <span class="hljs-built_in">swap</span>(hp[a],hp[b]);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(h[x/<span class="hljs-number">2</span>]&lt;=h[x])<span class="hljs-keyword">break</span>;<br>                <span class="hljs-built_in">heap_swap</span>(x/<span class="hljs-number">2</span>,x);<br>                x/=<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>                <span class="hljs-type">int</span> t=x;<br>                <span class="hljs-keyword">if</span>(x*<span class="hljs-number">2</span>&lt;=n&amp;&amp;h[x*<span class="hljs-number">2</span>]&lt;h[t])t=x*<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(x*<span class="hljs-number">2</span><span class="hljs-number">+1</span>&lt;=n&amp;&amp;h[x*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]&lt;h[t])t=x*<span class="hljs-number">2</span><span class="hljs-number">+1</span>;<br>                <span class="hljs-keyword">if</span>(t==x)<span class="hljs-keyword">break</span>;<br>                <span class="hljs-built_in">heap_swap</span>(x,t);<br>                x=t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            h[++n]=x;<br>            ph[++idk]=n;<br>            hp[n]=idk;<br>            <span class="hljs-built_in">up</span>(n);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getmin</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> h[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delmin</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-built_in">heap_swap</span>(<span class="hljs-number">1</span>,n--);<br>            <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delid</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>            <span class="hljs-type">int</span> ok=ph[k];<br>            <span class="hljs-built_in">heap_swap</span>(ph[k],n--);<br>            <span class="hljs-built_in">down</span>(ok);<br>            <span class="hljs-built_in">up</span>(ok);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeid</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<br>            h[ph[k]]=x;<br>            <span class="hljs-built_in">down</span>(ph[k]);<br>            <span class="hljs-built_in">up</span>(ph[k]);<br>        &#125;<br>&#125;hp;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>树论</tag>
      
      <tag>堆</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Union_Find_Set并查集</title>
    <link href="/2024/08/02/Union-Find-Set/"/>
    <url>/2024/08/02/Union-Find-Set/</url>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>以接近O(1)的复杂度合并集合并查询两个元素是否在同一个集合中的简介好用数据结构。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>将每个集合视作一棵树，每个节点储存它的父节点。特别地，根节点储存它本身。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>将每个点的父节点都设为它本身。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>将其中一个集合的根节点的父节点设为另一个集合的根节点。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>看两个点在不在同一个集合中，也就是看两个点的根节点一样不一样。</p><h2 id="优化（路径压缩）"><a href="#优化（路径压缩）" class="headerlink" title="优化（路径压缩）"></a>优化（路径压缩）</h2><p>其实还可以按秩合并，但那个优化代码量相对较大，并且基本上没有毛用，所以就不讲了。</p><p>路径压缩，就是在查询根节点的过程中，把当前节点的父节点直接设为祖先节点，以大大减少合并、查询的时间复杂度。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h2><p>只有最基础的初始化、查询、合并功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Union_Find_Set</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> n,p[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            n=x;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>                p[i]=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(p[x]!=x)p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>            <span class="hljs-keyword">return</span> p[x];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            a=<span class="hljs-built_in">find</span>(a);b=<span class="hljs-built_in">find</span>(b);<br>            p[a]=b;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b);<br>        &#125;<br>&#125;ufs;<br></code></pre></td></tr></table></figure><h2 id="计数版"><a href="#计数版" class="headerlink" title="计数版"></a>计数版</h2><p>可以记录每个集合内的元素个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Union_Find_Set</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> n,p[N],siz[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            n=x;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>                p[i]=i;<br>                siz[i]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(p[x]!=x)p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>            <span class="hljs-keyword">return</span> p[x];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            a=<span class="hljs-built_in">find</span>(a);b=<span class="hljs-built_in">find</span>(b);<br>            <span class="hljs-keyword">if</span>(a!=b)siz[b]+=siz[a];<br>            p[a]=b;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)];<br>        &#125;<br>&#125;ufs;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/description/242/">AcWing240-食物链</a></p><p><a href="https://www.luogu.com.cn/problem/P2024">Luogu2024-食物链</a></p><p>（这是同一道题~话说洛谷的题号真吉利(～￣▽￣)～）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1.5e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Union_Find_Set</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> n,p[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            n=x;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>                p[i]=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(p[x]!=x)p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>            <span class="hljs-keyword">return</span> p[x];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            a=<span class="hljs-built_in">find</span>(a);b=<span class="hljs-built_in">find</span>(b);<br>            p[a]=b;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b);<br>        &#125;<br>&#125;ufs;<br><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> d,x,y;<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin&gt;&gt;n&gt;&gt;k;<br>    ufs.<span class="hljs-built_in">init</span>(n*<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        cin&gt;&gt;d&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(x&gt;n||y&gt;n)&#123;<br>            ans++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(d==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(ufs.<span class="hljs-built_in">same</span>(x,y+n)||ufs.<span class="hljs-built_in">same</span>(x+n,y))&#123;<br>                ans++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            ufs.<span class="hljs-built_in">merge</span>(x,y);<br>            ufs.<span class="hljs-built_in">merge</span>(x+n,y+n);<br>            ufs.<span class="hljs-built_in">merge</span>(x+n+n,y+n+n);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(ufs.<span class="hljs-built_in">same</span>(x,y)||ufs.<span class="hljs-built_in">same</span>(x,y+n))&#123;<br>                ans++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            ufs.<span class="hljs-built_in">merge</span>(x+n,y);<br>            ufs.<span class="hljs-built_in">merge</span>(x+n+n,y+n);<br>            ufs.<span class="hljs-built_in">merge</span>(x,y+n+n);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>树论</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Trie_Tree字典树</title>
    <link href="/2024/08/02/Trie-Tree/"/>
    <url>/2024/08/02/Trie-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>听起来很高大上，事实上很简单（￣︶￣）</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>快速存储和查询字符串。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>首先建立一颗树，根节点为空节点。</p><ul><li>插入时，一个字符一个字符地插入，每一个字符都作为上一个字符的子节点存在。如果上一个字符有对应的子节点，就直接进行下一个字符的操作；如果没有，就先新建一个，然后再进行下一步操作。最后一个字符打一个标记，表示这里有一个单词。（如果需要还可以储存下个数）</li><li>查询时，也是一个字符一个字符查询。如果某个节点没有下一个字符的子节点，或者最后一个节点处没有打标记，就说明没有这个单词，否则就有这个单词。</li></ul><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">trie_tree</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>],cnt[N],idk;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string str)</span></span>&#123;<br>            <span class="hljs-type">int</span> now=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();i++)&#123;<br>                <span class="hljs-type">int</span> t=str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(!son[now][t])son[now][t]=++idk;<br>                now=son[now][t];<br>            &#125;<br>            cnt[now]++;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(string str)</span></span>&#123;<br>            <span class="hljs-type">int</span> now=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();i++)&#123;<br>                <span class="hljs-type">int</span> t=str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(!son[now][t])<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                now=son[now][t];<br>            &#125;<br>            <span class="hljs-keyword">return</span> cnt[now];<br>        &#125;<br>&#125;tt;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1><p><em>写了几篇费脑博客，再写这篇，真的热泪盈眶(≧∇≦)</em></p>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>树论</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-KMP</title>
    <link href="/2024/08/02/KMP/"/>
    <url>/2024/08/02/KMP/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>KMP真的<strong>很不好理解</strong>，但其实理解了原理，<strong>代码就没有任何的问题了</strong>。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="总概"><a href="#总概" class="headerlink" title="总概"></a>总概</h2><p>KMP嘛，其实就是优化字符串匹配的过程。</p><p>优化的终点就是当前点匹配不上时的操作。对比如下：</p><ul><li>暴力算法：后移一位，从头开始匹配。</li><li>KMP算法：找到匹配串中距离当前点最近的可以与被匹配串匹配的点，直到当前点可以匹配为止。</li></ul><p>（这句话可能有点绕，但学完整个算法就理解了。）</p><p>（至于为什么把它分在数据结构……<del>你就说next数组存没存数据吧</del>）</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>整个KMP算法其实分为两步：</p><ol><li>找next数组</li><li>匹配！</li></ol><p>至于具体怎么做，马上就知道了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="找next数组"><a href="#找next数组" class="headerlink" title="找next数组"></a>找next数组</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>next数组，其实就是寻找如果当前点匹配不上，<strong>上一个最近的可以匹配的点</strong>。重点，就在于如何判断<strong>可以匹配</strong>。</p><p>假设被匹配字符串到了第i个元素，匹配字符串到了第j个元素，那么可以肯定的是，两个字符串当前元素前面的元素，一定是完全相等的。<em>不然就没法匹配当前元素了~</em></p><ul><li>如果当前元素相同，那最好，i和j各自前进一位，把刚才进行匹配的元素加入前面已经完成匹配的部分中。</li><li>如果当前元素不同，那就到了next数组发挥作用的时候了。</li></ul><p>将两个字符串中已经匹配好的子串单独拿出来（包括被匹配串中移出的部分），可以看出，被匹配串的后缀，与匹配串是完全相同的。</p><p>之所以这样，是因为在匹配的过程中，匹配串肯定是从前往后进行匹配的，因此它的前缀必须先完成匹配。在这个匹配过程中，匹配串肯定是在向后移动，那么被匹配串中肯定就有元素匹配不上，那么这些元素就全都排在当前完成匹配的元素的前面，所以当前被匹配串子串的后缀肯定是完成匹配了的。</p><p>（这里不是说被匹配串整个串，只是当前对比元素的前面形成的完成匹配的子串）</p><p>所以可以得出，前缀与被匹配串的后缀相同的匹配串可以进行匹配。</p><p>那么上一个可以进行匹配的元素，肯定也满足这个性质。</p><p>当前的子串与被匹配串后缀相等，但是后一个元素无法匹配，就需要找到上一个在匹配串中满足条件的子串，用它的后一位元素再与被匹配串中当前匹配元素匹配。</p><p><strong>所以新的元素的前缀也要与被匹配串的后缀相同。</strong></p><p><strong>而被匹配串的当前的最大相同后缀，其实就是匹配串当前已经完成匹配的子串。</strong></p><p><strong>后缀的后缀和前缀的前缀一定相同。</strong></p><p><strong>所以也就是要找到匹配串前缀中最长的前缀，与被匹配串后缀中最长的后缀相同。</strong></p><p><strong>联立第二句话与第四句话，当前最长的满足条件的子串就是当前匹配串子串中最大公共前后缀。</strong></p><p><strong>所以下一个匹配的元素就是最大公共前缀的后一位。也就是next数组中的存储的东西了。</strong></p><p>归根结底，找next数组的过程，其实就是不断找最大公共前后缀的过程。</p><p>找的是当前匹配元素之前形成的子串中的最大前缀的后一位元素。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>现在问题就变成了找当前元素之前的子串（不包括当前元素）的最长公共前后缀大小的问题。</p><p>假设已经完成了第i个元素，它的next是j。<br>（相当于从第1个元素到第i-1个元素形成的子串中，最长公共前后缀长度是j-1）</p><p>现在，我们就对比元素i与元素j。</p><ul><li>如果相同，那么<code>next[i+1]=j+1</code>，因为后缀新加入了一个与前缀新加入的元素相同的元素，还是最长公共前后缀，长度增加了一。最后<code>j++, i++</code>就行了。</li><li>如果不同，也就相当于两个字符串匹配的过程，j不断地去找上一个满足条件的元素<code>j=next[j]</code>，直到当前元素j与元素i相同为止，<code>next[i+1]=j+1</code>，然后<code>j++, i++</code>。</li><li>如果所有元素都不同，特计<code>next[i+1]=0</code>，表示无法匹配，后移一位重启匹配。</li></ul><p>然后一直循环，直到整个匹配串找完为止。</p><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>怎么匹配？其实就跟找next数组一模一样，不过并不是对比同一个字符串的前后缀，而是匹配匹配串的前缀和被匹配串的后缀罢了。</p><p>思路其实是完全相同的。当匹配串完成了最后一个元素的匹配时，就说明整个串都完成匹配了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://www.acwing.com/problem/content/description/833/">AcWing831-KMP字符串</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>,M=<span class="hljs-number">1e6</span><span class="hljs-number">+6</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">char</span> p[N],s[M];<br><span class="hljs-type">int</span> ne[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;p<span class="hljs-number">+1</span>&gt;&gt;m&gt;&gt;s<span class="hljs-number">+1</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=n)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||p[i]==p[j]) ne[++i]=++j;<br>        <span class="hljs-keyword">else</span> j=ne[j];<br>    &#125;<br>    i=j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=m)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||s[i]==p[j]) i++,j++;<br>        <span class="hljs-keyword">else</span> j=ne[j];<br>        <span class="hljs-keyword">if</span>(j==n<span class="hljs-number">+1</span>)&#123;<br>            cout&lt;&lt;i-n<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            j=ne[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1><p><em>愉快地亖了</em></p>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>字符串</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Monotonic_Queue单调队列</title>
    <link href="/2024/08/01/Monotonic-Queue/"/>
    <url>/2024/08/01/Monotonic-Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>单调队列，在STL中有<code>priority_queue</code>（其实人家是堆hh），可以完成很多操作。事实上，还有个更响亮的名字，和pq完全分割，作为一个单独的算法存在——<strong>滑动窗口</strong>。</p><p>而滑动窗口，就对手写单调队列的能力要求比较高了。</p><p>本博客会在单调栈的基础上讲解，所以不会的自助吧。</p><p><a href="https://githarlem.github.io/2024/08/01/Monotonic-Stack/">“[编程笔记]-Monotonic_Stack单调栈”</a></p><p><a href="https://githarlem.github.io/2024/08/01/Queue/"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>具有单调性的队列。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>不至于，朋友，在单向队列里维护单调性耗得时间简直了o(<em>￣︶￣</em>)o</p><p>所以需要单调队列的话就直接用STL库吧，手写STL单调队列的内容我是不会放在这里写的。</p><p>通常情况下在队列中维护单调性都需要双端队列，也就是栈和队列的结合体。</p><p>但事实上那个算法和单调栈一毛一样，就多了个去除队首元素的内容（滑动窗口特色）。</p><p><em>你想，维护单调性肯定是从队尾维护啊~</em></p><p>然后呢，通常意义上滑动窗口的算法，维护的是一种很新的单调性。它会把队首和队尾所有不符合要求（不一定是同一个要求）的全部去掉，然后把元素插到队尾上去，其实不是很满足单调队列的要求。至于新在哪里，就是它对于队头元素也有要求，所以才会达到窗口移动而不是扩张的目的。（不然答案就固定了，一直是队头元素）</p><p>所以就直接给例题吧。</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>开个部分告诉你，会在例题中讲解滑动窗口问题。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/156/">AcWing154-滑动窗口</a></p><p>这题名字叫滑动窗口，但事实上和广义上的滑动窗口还是有区别的。</p><p><em>在这道题中，窗口队头更新的条件是队列大小过大，而广义的滑动窗口算法中队头更新的条件并非一定是队列大小限制。</em></p><p>但是它用的也就是滑动窗口算法，只是说滑动窗口算法不只是这道题中的算法而已。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不想打class了，就这样吧，理解就行</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span><span class="hljs-number">+6</span>;<br><br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-type">int</span> h1,t1,h2,t2;<br><span class="hljs-type">int</span> s1[N],s2[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(h1&lt;t1&amp;&amp;i-s1[h1<span class="hljs-number">+1</span>]<span class="hljs-number">+1</span>&gt;k)h1++;<br>        <span class="hljs-keyword">while</span>(h1&lt;t1&amp;&amp;a[s1[t1]]&gt;=a[i])t1--;<br>        s1[++t1]=i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k)cout&lt;&lt;a[s1[h1<span class="hljs-number">+1</span>]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(h2&lt;t2&amp;&amp;i-s2[h2<span class="hljs-number">+1</span>]<span class="hljs-number">+1</span>&gt;k)h2++;<br>        <span class="hljs-keyword">while</span>(h2&lt;t2&amp;&amp;a[s2[t2]]&lt;=a[i])t2--;<br>        s2[++t2]=i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k)cout&lt;&lt;a[s2[h2<span class="hljs-number">+1</span>]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>队列</tag>
      
      <tag>手打STL</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Monotonic_Stack单调栈</title>
    <link href="/2024/08/01/Monotonic-Stack/"/>
    <url>/2024/08/01/Monotonic-Stack/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>具有单调性的栈（站内元素单调递增或单调递减）</p><h1 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h1><p>问数组中每一个元素左侧&#x2F;右侧离它最近的比它大&#x2F;小的元素是什么。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monotonic_Stack</span>&#123;<span class="hljs-comment">//这里是单调递减，要改的话改fix()就行了。</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> a[N];<br>        <span class="hljs-type">int</span> size;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> size==<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a[size];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>            size--;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fix</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//维护单调性</span><br>            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">empty</span>()&amp;&amp;<span class="hljs-built_in">top</span>()&gt;=x)<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//单调插入</span><br>            <span class="hljs-built_in">fix</span>(x);<br>            a[++size]=x;<br>        &#125;<br>&#125;ms;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>就是上面说的经典题型。</p><p><a href="https://www.acwing.com/problem/content/832/">AcWing830-单调栈</a></p><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>还是讲解一下吧。</p><p>维护栈单调性可做的证明：</p><p>若a[i]≥a<a href="i%3Cj">j</a>，那么在j之后所有结果可以是i的，j都会是更优解。所以i绝对不可能作为答案出现，可以排除。</p><p>这样，就只需要维护一个单调递增的栈就行了。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monotonic_Stack</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> a[N];<br>        <span class="hljs-type">int</span> size;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> size==<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a[size];<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>            size--;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fix</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">empty</span>()&amp;&amp;<span class="hljs-built_in">top</span>()&gt;=x)<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            <span class="hljs-built_in">fix</span>(x);<br>            a[++size]=x;<br>        &#125;<br>&#125;ms;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        ms.<span class="hljs-built_in">fix</span>(a[i]);<br>        <span class="hljs-keyword">if</span>(!ms.<span class="hljs-built_in">empty</span>()) cout&lt;&lt;ms.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-number">-1</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        ms.<span class="hljs-built_in">push</span>(a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>手打STL</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-queue队列</title>
    <link href="/2024/08/01/Queue/"/>
    <url>/2024/08/01/Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一种先进先出的数据结构，就像排队一样。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Static_Queue</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> front,back;<span class="hljs-comment">//这里front可以视作第0个元素，它的下一位才是第一个真正的元素。</span><br>        <span class="hljs-type">int</span> a[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            a[++back]=x;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>            front++;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> front==back;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a[front<span class="hljs-number">+1</span>];<br>        &#125;<br>&#125;sq;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>队列</tag>
      
      <tag>手打STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Stack栈</title>
    <link href="/2024/08/01/Stack/"/>
    <url>/2024/08/01/Stack/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为STL库自带的数据结构，我就不多详细的解释了，主要记录一下手写的代码。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>一种先进后出的数据结构，可以视为有底瓶。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Static_Stack</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> top;<br>        <span class="hljs-type">int</span> a[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>            a[++top]=x;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>            top--;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> top==<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> a[top];<br>        &#125;<br>&#125;ss;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/3305/">AcWing3302-表达式求值</a></p><p>经典例题，并且不是很好写，故留作记录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>stack&lt;<span class="hljs-type">char</span>&gt; ops;<br><br>string str;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> op=ops.<span class="hljs-built_in">top</span>();ops.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> n2=nums.<span class="hljs-built_in">top</span>();nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> n1=nums.<span class="hljs-built_in">top</span>();nums.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;+&#x27;</span>)<span class="hljs-keyword">return</span> n1+n2;<br>    <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;-&#x27;</span>)<span class="hljs-keyword">return</span> n1-n2;<br>    <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;*&#x27;</span>)<span class="hljs-keyword">return</span> n1*n2;<br>    <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;/&#x27;</span>)<span class="hljs-keyword">return</span> n1/n2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;str;<br>    <span class="hljs-type">int</span> t;<span class="hljs-type">bool</span> pd;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t=<span class="hljs-number">0</span>;pd=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(str[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;str[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            pd=<span class="hljs-literal">true</span>;<br>            t=t*<span class="hljs-number">10</span>+(str[i++]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pd) nums.<span class="hljs-built_in">push</span>(t);<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;*&#x27;</span>||str[i]==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>()&amp;&amp;(ops.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;*&#x27;</span>||ops.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;/&#x27;</span>))&#123;<br>                nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">count</span>());<br>            &#125;<br>            ops.<span class="hljs-built_in">push</span>(str[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;+&#x27;</span>||str[i]==<span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>()&amp;&amp;ops.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">count</span>());<br>            &#125;<br>            ops.<span class="hljs-built_in">push</span>(str[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            ops.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span>(ops.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">count</span>());<br>            &#125;<br>            ops.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!ops.<span class="hljs-built_in">empty</span>())&#123;<br>        nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">count</span>());<br>    &#125;<br>    cout&lt;&lt;nums.<span class="hljs-built_in">top</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>手打STL</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Double-Linked_Lists双链表</title>
    <link href="/2024/08/01/Double-Linked-Lists/"/>
    <url>/2024/08/01/Double-Linked-Lists/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>鉴于双链表和单链表基本上一毛一样，所以不会重新再写一遍链表基本操作，详见<a href="https://githarlem.github.io/2024/08/01/Single-Linked-Lists/">“[编程笔记]-Single-Linked_Lists单链表”</a>。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>就是双向链表，每个节点既指向后一个元素，又指向前一个元素。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><em>对没错就是这么懒( •̀ ω •́ )✧</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Double_linked_lists</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> head,tail,cnt;<br>        <span class="hljs-type">int</span> e[N],ne[N],la[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> h=<span class="hljs-number">0</span>)</span></span>&#123;<br>            head=h;tail=n<span class="hljs-number">+1</span>;<br>            ne[head]=tail;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_next</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<br>            ++cnt;<br>            e[cnt]=x;<br>            ne[cnt]=ne[k];<br>            ne[k]=cnt;<br>            la[cnt]=k;<br>            la[ne[cnt]]=cnt;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_last</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//其实这里可以直接转成add_next()，但为了方便学习还是手打了一遍。</span><br>            ++cnt;<br>            e[cnt]=x;<br>            la[cnt]=la[k];<br>            la[k]=cnt;<br>            ne[la[cnt]]=cnt;<br>            ne[cnt]=k;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//删除编号为k的节点。</span><br>            ne[la[k]]=ne[k];<br>            la[ne[k]]=la[k];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ne[head];i!=tail;i=ne[i])&#123;<br>                vec.<span class="hljs-built_in">push_back</span>(e[i]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> vec;<br>        &#125;<br>&#125;dll;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Single-Linked_Lists单链表</title>
    <link href="/2024/08/01/Single-Linked-Lists/"/>
    <url>/2024/08/01/Single-Linked-Lists/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开新章啦。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>链表中，每一个元素都有一个指向下一个元素的指针，这样一个链接一个，就形成了一个链式结构。</p><h1 id="动态链表"><a href="#动态链表" class="headerlink" title="动态链表"></a>动态链表</h1><p>动态链表通常就是真正意义上的链表，可以动态增加、修改、减少，但事实上用处并不大，这里就只给出模板，用以借鉴。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<span class="hljs-comment">//组成链表的结点</span><br><span class="hljs-type">int</span> data;<br>node* next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>在竞赛中，静态链表才是大头。同时，在之后，我们会学到<strong>链式前向星</strong>，与链表的关系不能说微乎其微，也只能说是一模一样。</p><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>拿数组去模拟链表。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>同时开两个数组，储存对应<strong>编号</strong>的节点的数据和下一个节点的<strong>编号</strong>（编号不是元素在链表中的位置序号！）</p><p>这样就能通过修改对应数组的方式实现链表操作。</p><p>具体功能在代码中给出</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Static_linked_list</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> head,tail,cnt;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">注意，头指针并不是第一个元素，而是指向第一个元素的指针，可以视作第零号元素。</span><br><span class="hljs-comment">尾指针同理，并不是最后一个元素，而是最后一个元素指向的元素，作为结束的标志。</span><br><span class="hljs-comment">*/</span><br>        <span class="hljs-type">int</span> ne[N],e[N];<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> h=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>)</span></span>&#123;<br>            head=h;tail=t;<br>            ne[head]=tail;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span>&#123;<span class="hljs-comment">//在**编号为k**的元素**后**增加一个新元素。</span><br>            ++cnt;<span class="hljs-comment">//这就是编号，所以和位置没有任何关系。</span><br>            e[cnt]=x;<br>            ne[cnt]=ne[k];<br>            ne[k]=cnt;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<span class="hljs-comment">//删除**编号为k**的元素**后**一位元素。</span><br>            ne[k]=ne[ne[k]];<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//获取当前链表</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; lis;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=ne[head];i!=tail;i=ne[i])&#123;<br>                lis.<span class="hljs-built_in">push_back</span>(e[i]);<br>            &#125;<br>            <span class="hljs-keyword">return</span> lis;<br>        &#125;<br>&#125;sll;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/828/">AcWing826-单链表</a></p><p>一道模板题。</p><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Discretization离散化</title>
    <link href="/2024/07/31/Discretization/"/>
    <url>/2024/07/31/Discretization/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>离散化和哈希差不多，但是还是有点区别。</p><ul><li>离散化中元素按顺序获取地址，与元素值没有直接关联；而哈希中元素地址就是元素数值通过哈希函数获得的。</li><li>离散化需要二分预处理出所有地址，哈希是查询时在线计算地址。</li></ul><p>如果有需要，可以看看哈希：</p><p><a href="https://githarlem.github.io/2024/08/02/Hash-Table/">“[编程笔记]-Hash_Table哈希表”</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当遇到数值地址范围很大、数值量很少的问题时，可以使用离散化（或哈希）。</p><p>对原数组中所有地址进行排序、去重，然后记录每个地址对应的新地址，再用新地址储存元素，需要旧地址时以新地址为下标查询完成排序去重的数组即可。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//排序</span><br>vec.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>()),vec.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//去重</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:orgn)&#123;<span class="hljs-comment">//用pair储存加值操作，这里执行</span><br><span class="hljs-type">int</span> x=<span class="hljs-built_in">bfind</span>(item.first)<span class="hljs-comment">//二分查询新地址</span><br><span class="hljs-type">int</span> c=item.second;<span class="hljs-comment">//加值</span><br>a[x]+=c;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/804/">AcWing802-区间和</a></p><p>这是一道融合了前缀和、二分查找、离散化的<del>毒瘤</del>好题，值得一刷。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span><span class="hljs-number">+5</span>;<span class="hljs-comment">//增值操作一次一个地址，查询操作一次两个地址，一共三倍的大小。</span><br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,c;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-type">int</span> a[N],s[N];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; locs;<span class="hljs-comment">//储存所有地址</span><br>vector&lt;pii&gt; add,ask;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfind</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<span class="hljs-comment">//这里本来应该有个二分，但是我懒（￣︶￣）不会的可以去二分那一篇笔记看最后的拓展</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(locs.<span class="hljs-built_in">begin</span>(),locs.<span class="hljs-built_in">end</span>(),num)-locs.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+1</span>;<span class="hljs-comment">//之所以加一是为了方便前缀和</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dis</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sort</span>(locs.<span class="hljs-built_in">begin</span>(),locs.<span class="hljs-built_in">end</span>());<br>    locs.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(locs.<span class="hljs-built_in">begin</span>(),locs.<span class="hljs-built_in">end</span>()),locs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:add)&#123;<br>        x=<span class="hljs-built_in">bfind</span>(item.first);<br>        c=item.second;<br>        a[x]+=c;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;c);<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;);<br>        locs.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        ask.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>        locs.<span class="hljs-built_in">push_back</span>(l);<br>        locs.<span class="hljs-built_in">push_back</span>(r);<br>    &#125;<br>    <span class="hljs-built_in">dis</span>();<span class="hljs-comment">//离散化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;locs.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>;i++)&#123;<span class="hljs-comment">//因为所有地址手动加了1，所以最大值也要加1。</span><br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:ask)&#123;<br>        l=<span class="hljs-built_in">bfind</span>(item.first);<br>        r=<span class="hljs-built_in">bfind</span>(item.second);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>离散化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Lowbit取最小1</title>
    <link href="/2024/07/31/Lowbit/"/>
    <url>/2024/07/31/Lowbit/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>lowbit是树状数组的基础啊，其重要性可想而知。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br><span class="hljs-keyword">return</span> a&amp;-a;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="演算"><a href="#演算" class="headerlink" title="演算"></a>演算</h1><p>众所周知，在二进制中，<code>-a</code>等同于<code>~a+1</code>（a的值取反再加一）</p><p>a取反后，所有1变成0，0变成1，因此在原数中第一个1出现前，全都是1。</p><p>故而，再加上一个一，第一个1前面全部变成0，第一个1本来取反变成0了，进位又变回1，然后就结束了，它后面的数字照样是原数取反的结果。</p><p>这时候进行与运算，那么a中第一个1前面的全都是0，-a中第一个1前面的也全都是0，新数就全是0；</p><p>第一个1后面的全都和原数取反，所以在新数中也是0。故而，就得到了第一个1组成的新数。</p><p>举例：</p><blockquote><p>a&#x3D;1010011000<br><del>a&#x3D;0101100111<br>-a&#x3D;</del>a+1&#x3D;0101101000<br>a&amp;-a&#x3D;1010011000&amp;0101101000&#x3D;0000001000</p></blockquote><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/803/">AcWing801-二进制中1的个数</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a,ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> num&amp;-num;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br>        ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(a)&#123;<br>            a-=<span class="hljs-built_in">lowbit</span>(a);<br>            ans++;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Two_Pointers双指针</title>
    <link href="/2024/07/31/Two-Pointers/"/>
    <url>/2024/07/31/Two-Pointers/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近时间紧迫，从这篇文章开始，就着重记笔记了，不再提供详细教程。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>双指针算法，名义上说就是使用两个指针循环（一个或多个）数组，但实际上通常用不到指针。</p><p>一般情况下，双指针算法用于特定情境，将O(n<sup>2</sup>)的时间复杂度简化成O(n)。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>一般情况下，形如下方所示的代码，在满足特定需求的情况下，都可以转化成双指针来做。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i,j))&#123;<br><span class="hljs-comment">//功能代码</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>转化成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">check</span>(i,j))&#123;<br>j++;<br>&#125;<br><span class="hljs-comment">//功能代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.acwing.com/problem/content/801/">AcWing799-最长连续不重复子序列</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-type">int</span> a[N],s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        s[a[i]]++;<br>        <span class="hljs-keyword">while</span>(s[a[i]]&gt;<span class="hljs-number">0</span>)&#123;<br>            s[a[j++]]--;<br>        &#125;<br>        ans=<span class="hljs-built_in">max</span>(ans,i-j<span class="hljs-number">+1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Adjacent_Difference差分</title>
    <link href="/2024/07/30/Adjacent-Difference/"/>
    <url>/2024/07/30/Adjacent-Difference/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>差分是前缀和的逆运算，因此思想与之差不多。所以，为了更好地理解，如果有需要，请事先阅读<a href="https://githarlem.github.io/2024/07/30/Partial-Sum/">“[编程笔记]-Partial_Sum前缀和”</a>。</p><h1 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h1><h2 id="思想及实现"><a href="#思想及实现" class="headerlink" title="思想及实现"></a>思想及实现</h2><p>同理，一维差分也可视为对差分的引入。</p><p>差分作为前缀和的逆运算，定义也与之相反。具体地说，对于数组<code>a[]</code>，**它的差分数组前i项之和等于a[i]**，即为<code>a[i]=b[0]+b[1]+...+b[i]</code>。</p><p>差分的主要作用是快速实现<strong>区间修改</strong>，若要使从<em>l</em>到<em>r</em>的区间内元素同时增加<em>c</em>，令<code>b[i]=a[i]-a[i-1]</code>，则可以<strong>使b数组第l位+c、第r+1位-c，那么从l开始，往后所有元素+c，直到第r+1位恢复原状</strong>。</p><p>上述思想十分重要，将会对后面的二维差分部分有很大帮助。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> l,r,c;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    b[l]+=v;<br>    b[r<span class="hljs-number">+1</span>]-=v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        <span class="hljs-built_in">insert</span>(i,i,a[i]);<span class="hljs-comment">//初始化b数组，视作在第i位增加a[i]大小。</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        a[i]=a[i<span class="hljs-number">-1</span>]+b[i];<span class="hljs-comment">//递推实现差分</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h1><p><strong>难点！难点！难点！</strong></p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先是初始化。为了方便，我这边就直接定义我的算法中差分数组的作用了：</p><p>以原点为左上角、当前点为右下角形成矩阵，当前点的数值，就是差分数组在矩阵内的所有元素之和。</p><p>因此，当前点的数值也就是除去当前点形成的“L”型加上当前点位置上的差分数组。</p><p>鉴于该过程与前缀和中的过程基本上完全一致，只需要调转名称即可，故而就不额外配图，如有需要，前言部分中链接自取。</p><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>然后就是区间修改部分了：</p><h4 id="修改单点的效果"><a href="#修改单点的效果" class="headerlink" title="修改单点的效果"></a>修改单点的效果</h4><p>为了理解算法，我们要先理解如果修改一个点的差分值会发生什么。</p><p>已知每个点的数值与其对应的“L”型有关，又可直接视作它与原点形成的矩阵，因而一旦其矩阵中包含被修改的元素，其数值也会收到影响：</p><p><img src="/t0.png" alt="红色为修改元素，图中只有棕色点受影响"></p><p>故而会受到影响的元素图如下：</p><p><img src="/t1.png" alt="如图"></p><p>那么现在再去理解区间修改就简单多了。</p><h4 id="步入正轨"><a href="#步入正轨" class="headerlink" title="步入正轨"></a>步入正轨</h4><p>已知受影响区间在当前点的右下角，也就是和前缀和刚好相反的，那么在此就不重复推算思路了，也就是矩阵减去“L”型。</p><p>而差分中无论是矩阵还是“L”型都在右下方，其他与前缀和基本完全一致。</p><p>如果需要详细推演过程麻烦上前言链接自取。</p><h3 id="更新原数组"><a href="#更新原数组" class="headerlink" title="更新原数组"></a>更新原数组</h3><p>根据初始化部分中对于差分数组的定义，我们可以将原数组视作前缀和、差分数组视作前缀和中的原数组，直接代公式即可。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="区间修改-1"><a href="#区间修改-1" class="headerlink" title="区间修改"></a>区间修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    b[x1][y1]+=c;<br>    b[x1][y2<span class="hljs-number">+1</span>]-=c;<br>    b[x2<span class="hljs-number">+1</span>][y1]-=c;<br>    b[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>]+=c;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新原数组-1"><a href="#更新原数组-1" class="headerlink" title="更新原数组"></a>更新原数组</h3><p><code>a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j];</code></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span><span class="hljs-number">+3</span>;<br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> a[N][N],b[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    b[x1][y1]+=c;<br>    b[x1][y2<span class="hljs-number">+1</span>]-=c;<br>    b[x2<span class="hljs-number">+1</span>][y1]-=c;<br>    b[x2<span class="hljs-number">+1</span>][y2<span class="hljs-number">+1</span>]+=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>            <span class="hljs-built_in">insert</span>(i,j,i,j,a[i][j]);<span class="hljs-comment">//初始化b数组</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);<br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            a[i][j]=a[i<span class="hljs-number">-1</span>][j]+a[i][j<span class="hljs-number">-1</span>]-a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+b[i][j];<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>前缀和与差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Partial_Sum前缀和</title>
    <link href="/2024/07/30/Partial-Sum/"/>
    <url>/2024/07/30/Partial-Sum/</url>
    
    <content type="html"><![CDATA[<h1 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h1><h2 id="思想及实现"><a href="#思想及实现" class="headerlink" title="思想及实现"></a>思想及实现</h2><p>这里主要还是引入<strong>前缀和</strong>的思想，这个算法在后面还是挺常用的，可以搭配各种算法，减少时间复杂度。</p><p>前缀和呢，就是一个数组的某段前缀内的所有元素之和。举个栗子，<code>&#123;0,1,2,3,4,5,6&#125;</code>，对于这个数组，前四位的前缀和是<code>0+1+2+3==6</code>，前三位的前缀和是<code>0+1+2==3</code>。</p><p>前缀和的主要作用就是查询一段区间的元素之和。令<code>s[i]</code>表示<code>a[]</code>前i位的和，则<code>a[i]</code>就等于<code>s[i]-s[i-1]</code>。同理可推，<code>a[l]+a[l+1]+a[l+2]+...+a[r-2]+a[r-1]+a[r]</code>就等于<code>s[r]-s[l-1]</code>。</p><p><em>减去<code>s[l-1]</code>的原因：a[l]也在所需要的区间内，因此不能减去a[l]而只需减去a[l]左侧的全部元素。</em></p><p>通常情况下，我们会采取<strong>递推</strong>的方式预处理初前缀和，处理的复杂度是<code>O(n)</code>，而之后单次查询的复杂度则降到了<code>O(1)</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N],s[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> l,r;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从这里开始，我们接触的算法就开始烧脑了。</p><p>鉴于二位前缀和的复杂性（当然其实也没多复杂），我这边会搭配图片进行讲解。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二位前缀和呢，若将数组视作一个矩形（左上角为原点），则前缀和储存的就是以原点为左上角、终点为右下角的矩形内包括的所有元素的和。</p><p>因此，若要求一个点的前缀和，只需求出它对应矩形缺了它这个角形成的“L”型图形内的前缀和，再加上这个点本身的数值即可。具体怎么求“L”，我将会在实现部分中写。</p><p><img src="/init.png" alt="&quot;初始化&quot;"></p><p>接下来就是查询的时候了：</p><p>在二维前缀和问题中，所求问题多半是一段二维区间内的元素和。循序渐进，我们从查询单个元素开始说起：</p><p>（下图中每个方格表示一个元素，实心格子表示待求元素）</p><p><img src="/p0.png" alt="&quot;问题1&quot;"></p><p>其实也很简单，我们只需要把求前缀和的过程反过来就行了：用当前元素前缀和减去那个“L”型元素和即可。</p><p>延伸到一段元素，与单个元素的思路一模一样——用右下角元素的前缀和，减去包裹着整个区间的“L”型即可。</p><p><img src="/p1.png" alt="&quot;问题2&quot;"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>不管是求前缀还是计算区间，重点就是求L型。既然我们已知当前点左侧上侧的全部前缀和，为什么不把这个复杂图形切割成我们已知的图形去做呢？</p><p>很简单，把它分成如图所示的两个前缀和，再减去它们重叠的那部分即可。</p><p><img src="/s0.png" alt="&quot;解决&quot;"></p><p>已经有了思路，下面就直接上公式了:</p><p>求前缀和：<br>s[i][j]&#x3D;s[i][j-1]+s[i-1][j]-s[i-1][j-1]+a[i][j]</p><p>求[x1][y1]到[x2][y2]的元素之和:<br>s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1]</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span><span class="hljs-number">+3</span>;<br><br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> a[N][N],s[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>            s[i][j]=s[i][j<span class="hljs-number">-1</span>]+s[i<span class="hljs-number">-1</span>][j]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> x1,y1,x2,y2;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x2][y1<span class="hljs-number">-1</span>]-s[x1<span class="hljs-number">-1</span>][y2]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>前缀和与差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-High_Precision(Mul and Div)[SIM]高精度乘除法（基础版）</title>
    <link href="/2024/07/29/High-Precision-MulDiv-Simple/"/>
    <url>/2024/07/29/High-Precision-MulDiv-Simple/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>鉴于此篇博客用于学习or巩固基础部分，故而这里只记录大数与<code>int</code>类型的小数的乘除计算，大数乘大数将会在<a href="https://githarlem.github.io/High-Precison-MulDiv-Complex">“[编程笔记]-High_Precision(Mul and Div)[COM]高精度乘除法（提高版）”</a>教学。</p><p>emmm就这样吧(。·ω·。)</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>其实就跟<strong>列竖式</strong>差不多，把大数列在下面、小数列在上面，直接乘。</p><p><em>别忘了去前导0~</em></p><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>就是用机器去模拟手写嘛。鉴于除法相较于其他三种计算有些复杂，这里给出详细步骤：</p><ol><li>准备好记录结果与记录余数的变量。</li><li>从最高位开始往最低位遍历大数。</li><li>将余数乘十并加上大数的这一位，作为新的被除数。</li><li>记录新的被除数除以小数的商与新余数。</li><li>去掉前导零。</li></ol><p><em>tips: 如果你用的是<code>vector</code>储存，请在第5步前反转队列。（详见代码）</em></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())t+=a[i]*b;<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)c.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;vector&lt;<span class="hljs-type">int</span>&gt;,<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">div</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">int</span> &amp;b)&#123;<span class="hljs-comment">//同时返回结果和余数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        t=t*<span class="hljs-number">10</span>+a[i];<br>        c.<span class="hljs-built_in">push_back</span>(t/b);<span class="hljs-comment">//注意，这里是从最高位开始往最低位储存，所以最后要先反转过来。</span><br>        t%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(c.<span class="hljs-built_in">begin</span>(),c.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//记得#include&lt;algorithm&gt;</span><br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)c.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> &#123;c,t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-High_Precision(Add and Sub)高精度加减法</title>
    <link href="/2024/07/28/High-Precision-AddSub/"/>
    <url>/2024/07/28/High-Precision-AddSub/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客并不打算多细致地讲解高精度，但是！但是！我会给出代码模板，并且在注释中讲解大多数内容。</p><p>就这样吧。（￣︶￣）</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>emmm<strong>小学数学</strong>会吧？<del>不会您先别看了</del> 就用小学数学的思路做就完事了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这里使用vector储存大数，因为它自带size函数，当然直接用数组也没有问题。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||i&lt;b.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())t+=b[i];<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t)c.<span class="hljs-built_in">push_back</span>(t);<span class="hljs-comment">//最后可能还剩一个进位，不要忘了加回去。</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>update 2024&#x2F;7&#x2F;29: 一种更简洁的写法</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||i&lt;b.<span class="hljs-built_in">size</span>()||t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())t+=b[i];<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//同上</span><br><span class="hljs-comment">//此函数用于判断两个大数大小，下方的减法函数只支持大减小。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>()&gt;b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])<span class="hljs-keyword">return</span> a[i]&gt;b[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//此函数用于大减小，搭配上方函数使用即可。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())t-=b[i];<br>        c.<span class="hljs-built_in">push_back</span>((t<span class="hljs-number">+10</span>)%<span class="hljs-number">10</span>);<span class="hljs-comment">//此处浓缩了两种可能：t&lt;0，返回t+10；t≥0，返回t。</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>)t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)c.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//删除前置0。当只剩一位时不删（不然0就没了）。</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Binary_Search二分查找</title>
    <link href="/2024/07/28/Binary-Search/"/>
    <url>/2024/07/28/Binary-Search/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二分也算是比较普遍且常用的一个算法了，并且在前期还是个小难点，其相对复杂的类型以及边界问题通常让<em>蒟蒻</em>们很是头疼。</p><p>这一篇博客主要讲解<strong>二分查找</strong>的原理、模板等（不是<strong>二分答案</strong>），并不着重深入讲解其各种变式。</p><p>就这样吧(～￣▽￣)～</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>二分查找就是把一段元素分成两半，用中间值进行对比，判断查找元素在其左侧或右侧，并在那一半进行查找，以到达O(logn)的复杂度。</p><p>因此，理论上来说，所有<strong>单调性</strong>问题都可以用二分解决。当然，<strong>并非只有单调性问题才可以用二分解决</strong>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>二分的实现其实并不难，搞清楚原理后，基本上就没什么问题了。</p><p>这里还是大概贴下思路：</p><ol><li>确定搜索范围。</li><li>获取中间值。<strong>！注意，不同二分方式在这一步的具体实现会有所不同，详见下方！</strong></li><li>判断答案在左侧还是右侧。</li><li>在答案所在一侧重新二分，循环直到范围缩为1。</li><li>判断获得元素是否为所求，若否，则搜索范围中无需要元素。</li></ol><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p><em>整数二分有<strong>两种</strong>形式，我个人将其命名为<strong>左倾二分</strong>以及<strong>右倾二分</strong>（非！官！方！命！名！）</em></p><h3 id="左倾二分"><a href="#左倾二分" class="headerlink" title="左倾二分"></a>左倾二分</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>所谓_左倾_，就是说搜索到的答案<strong>倾向于向左侧靠近</strong>。举例地说，当一段元素中有连续的一段相同元素时，搜索此元素，得到的将会是这一段中最左侧的坐标。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>在计算中间坐标时，<strong>向下取整</strong>。原因会在第二点给出。</li><li>若中间值<strong>大于或等于</strong>答案，则将右边界重设为中间坐标。<strong>因此，中间坐标需向下取整，否则会陷入死循环</strong>。</li><li>否则，将左边界重设为中间坐标**+1**，原因是中间坐标已经确定不是答案，因此不在搜索范围内。</li></ul><h4 id="左倾原因"><a href="#左倾原因" class="headerlink" title="左倾原因"></a>左倾原因</h4><p>若当前搜索范围内值都一致，则都满足<strong>大于或等于</strong>答案，那么会一直重设右边界。同时，中间坐标向下取整，故而范围会一直向左缩小，直到缩小至一个元素，那么就是最左侧的元素了。</p><h3 id="右倾二分"><a href="#右倾二分" class="headerlink" title="右倾二分"></a>右倾二分</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>_右倾_定义可借鉴_左倾_，就是说搜索到的答案<strong>倾向于向右侧靠近</strong>，这里就不做具体阐释。</p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>在计算中间坐标时，<strong>向上取整</strong>。原因会在第三点给出。</li><li>若中间值<strong>大于</strong>答案，则将右边界重设为中间坐标**-1**，原因是中间坐标已经确定不是答案，因此不在搜索范围内。</li><li>否则，将左边界重设为中间坐标。<strong>因此，中间坐标需向上取整，否则会陷入死循环</strong>。</li></ul><h4 id="右倾原因"><a href="#右倾原因" class="headerlink" title="右倾原因"></a>右倾原因</h4><p>若当前搜索范围内值都一致，则都满足<strong>小于或等于</strong>答案，那么会一直重设左边界。同时，中间坐标向上取整，故而范围会一直向右缩小，直到缩小至一个元素，那么就是最右侧的元素了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><em>代码中check函数不固定，视需求而定</em></p><h4 id="左倾二分-1"><a href="#左倾二分-1" class="headerlink" title="左倾二分"></a>左倾二分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(m))r=m;<br>    <span class="hljs-keyword">else</span> l=m<span class="hljs-number">+1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="右倾二分-1"><a href="#右倾二分-1" class="headerlink" title="右倾二分"></a>右倾二分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> m=l+r<span class="hljs-number">+1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(m))r=m<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> l=m;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>浮点数二分相对于整数二分来说简单了很多，但需要注意的是，通常情况下是不能真正搜索到答案的，因此，当当前值与答案之间的差距足够小时，<strong>我们就视之为答案即可</strong>。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和整数二分差不多，取中间值时不存在取整问题，边界开闭随个人喜好。</p><p><strong>循环条件要写成边界之差大于一个较小值！（通常为1e-6以下，具体要求随题目而定）</strong></p><p><em>tips: 若题目有要求，则差值至少比保留小数位数多两位。</em></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> l=<span class="hljs-number">0</span>,r=x;<br><span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-6</span>)&#123;<br><span class="hljs-type">double</span> m=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(m))r=m;<br><span class="hljs-keyword">else</span> l=m;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p><em>update: 2024&#x2F;7&#x2F;31</em><br>STL库中有两个快速实现二分查找的函数。</p><h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound()"></a>upper_bound()</h2><p>查询第一个<strong>大于</strong>要求值的数，返回其<strong>迭代器</strong>。</p><p>故而，如果要获得其坐标，记得减去第一个元素的迭代器。</p><p>模板以<code>vector</code>为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfind</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">upper_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),num)-vec.<span class="hljs-built_in">begin</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound()"></a>lower_bound()</h2><p>和上一个差不多，查询第一个<strong>大于等于</strong>要求值的数，返回其<strong>迭代器</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfind</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),num)-vec.<span class="hljs-built_in">begin</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>搜索</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Merge_Sort归并排序</title>
    <link href="/2024/07/27/Merge-Sort/"/>
    <url>/2024/07/27/Merge-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>利用<strong>分治思想</strong>，把数组对半分成两份，各自排好序，再将两个排好序的数组合并成一个数组即可。</p><p>（或许有点废话？Σ(っ °Д °;)っ）</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>这里着重讲以下合并数组的过程：</p><ol><li><p>建立两个指针，指向两边各排好序的数组的首个元素。</p></li><li><p>对指针指向的元素进行对比，更小的（从小到大排序）插入临时数组，直到其中一个指针走到结尾。</p></li><li><p>把两个数组中剩下的元素插入临时数组（其实只会有一个有余，这里不做解释）</p></li><li><p>用临时数组替换原数组中对应元素段。</p></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N],t[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ms</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">ms</span>(l,m);<span class="hljs-built_in">ms</span>(m<span class="hljs-number">+1</span>,r);<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=m<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j])t[k++]=a[i++];<br><span class="hljs-keyword">else</span> t[k++]=a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=m)t[k++]=a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)t[k++]=a[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)a[i]=t[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">ms</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Quick_Sort快速排序</title>
    <link href="/2024/07/26/Quick-Sort/"/>
    <url>/2024/07/26/Quick-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h2><p>利用<strong>分治思想</strong>，新建两个数组，分别储存原数组中小于 X 或大于 X 的元素，并分别对其进行快速排序，最后重组原数组即可。（X可为任意值，推荐使用中值）</p><h2 id="进化版"><a href="#进化版" class="headerlink" title="进化版"></a>进化版</h2><p>利用<strong>分治思想</strong>以及部分<strong>双指针思想</strong>，左右各两个指针，记为 i, j。左指针一直向右，直到数组中第 i 个元素大于 x；右指针一直向左，直到数组中第 j 个元素小于x；接着左右指针<strong>对应元素</strong>互换，重复执行直到左右指针相遇。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>平均O(nlogn)，最大O(n<sup>2</sup>)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> x=q[l+r&gt;&gt;<span class="hljs-number">1</span>],i=l<span class="hljs-number">-1</span>,j=r<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(q[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(q[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q,l,j);<br>    <span class="hljs-built_in">quick_sort</span>(q,j<span class="hljs-number">+1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h1 id="蒟蒻的个人简介"><a href="#蒟蒻的个人简介" class="headerlink" title="蒟蒻的个人简介"></a>蒟蒻的个人简介</h1><h2 id="OIer"><a href="#OIer" class="headerlink" title="OIer"></a>OIer</h2><p>emmm目前就是个普三蒟蒻</p><p>所以究竟是哪个缺德学校把重庆变成强省的，我不说，自己对号入座 </p><p>凸(艹皿艹 )</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>好像还行？[雾]</p><p>虽然全校前百，但也只是个蒟蒻</p><p>(～￣▽￣)～</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>国内手游什么的完全无感（一堆抄袭怪）</p><p>P社<del>战犯</del>大元帅，五星好市民，以及别的一些小众，这个不重要，就提一嘴</p><p>（￣︶￣）</p><p>另外，求一个小灰立绘美化mod</p><p>( •̀ ω •́ )✧</p><h1 id="蒟蒻的中-ruo-二-zhi-身份"><a href="#蒟蒻的中-ruo-二-zhi-身份" class="headerlink" title="蒟蒻的中(ruo)二(zhi)身份"></a>蒟蒻的中(ruo)二(zhi)身份</h1><p>tips：非自愿，都是被<a href="https://www.luogu.com.cn/user/775936">Mingrui_Yang</a>大佬逼得。</p><h2 id="杨坤神教大主教"><a href="#杨坤神教大主教" class="headerlink" title="杨坤神教大主教"></a>杨坤神教大主教</h2><p>不是教主，教主是<a href="https://www.luogu.com.cn/user/775936">Mingrui_Yang</a>大佬。</p><p>不过我是圣主派的，他是正主派的，具体关系详见<a href="https://www.luogu.com.cn/problem/U456153">这道未完成烂题</a>。</p><p><em>顺便求下正解和数据，我们将会给大佬提供杨坤神教大主教之位！</em> </p><p><em>本蒟蒻的位子直接禅让了也可以</em> ヽ(￣ω￣(￣ω￣〃)ゝ</p><p>顺便宣传下，<a href="https://www.luogu.com.cn/team/61978">杨坤神教</a>，不违法，不摄政，团(fen)结(beng)一(li)新(xi)，共(feng)同(kuang)进(nei)步(juan)，中二骚年的最好选择！</p><p><del>我是<strong>自愿</strong>的(ノへ￣、)</del></p><h2 id="大元帅"><a href="#大元帅" class="headerlink" title="大元帅"></a>大元帅</h2><p>emmm这个不好多说，总之欢迎各位志同道合的同志们加入我们的<a href="https://www.luogu.com.cn/team/84599">团队</a></p><hr><p>THEEND</p>]]></content>
    
  </entry>
  
  
  
</search>
