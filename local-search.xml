<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[编程笔记]-Adjacent_Difference差分</title>
    <link href="/2024/07/30/Adjacent-Difference/"/>
    <url>/2024/07/30/Adjacent-Difference/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>前缀和与差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Partial_Sum前缀和</title>
    <link href="/2024/07/30/Partial-Sum/"/>
    <url>/2024/07/30/Partial-Sum/</url>
    
    <content type="html"><![CDATA[<h1 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h1><h2 id="思想及实现"><a href="#思想及实现" class="headerlink" title="思想及实现"></a>思想及实现</h2><p>这里主要还是引入<strong>前缀和</strong>的思想，这个算法在后面还是挺常用的，可以搭配各种算法，减少时间复杂度。</p><p>前缀和呢，就是一个数组的某段前缀内的所有元素之和。举个栗子，<code>&#123;0,1,2,3,4,5,6&#125;</code>，对于这个数组，前四位的前缀和是<code>0+1+2+3==6</code>，前三位的前缀和是<code>0+1+2==3</code>。</p><p>前缀和的主要作用就是查询一段区间的元素之和。令<code>s[i]</code>表示<code>a[]</code>前i位的和，则<code>a[i]</code>就等于<code>s[i]-s[i-1]</code>。同理可推，<code>a[l]+a[l+1]+a[l+2]+...+a[r-2]+a[r-1]+a[r]</code>就等于<code>s[r]-s[l-1]</code>。</p><p><em>减去<code>s[l-1]</code>的原因：a[l]也在所需要的区间内，因此不能减去a[l]而只需减去a[l]左侧的全部元素。</em></p><p>通常情况下，我们会采取<strong>递推</strong>的方式预处理初前缀和，处理的复杂度是<code>O(n)</code>，而之后单次查询的复杂度则降到了<code>O(1)</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><span class="hljs-type">int</span> a[N],s[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> l,r;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从这里开始，我们接触的算法就开始烧脑了。</p><p>鉴于二位前缀和的复杂性（当然其实也没多复杂），我这边会搭配图片进行讲解。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>二位前缀和呢，若将数组视作一个矩形（左上角为原点），则前缀和储存的就是以原点为左上角、终点为右下角的矩形内包括的所有元素的和。</p><p>因此，若要求一个点的前缀和，只需求出它对应矩形缺了它这个角形成的“L”型图形内的前缀和，再加上这个点本身的数值即可。具体怎么求“L”，我将会在实现部分中写。</p><p><img src="/2024/07/30/Partial-Sum/init.png" alt="&quot;初始化&quot;"></p><p>接下来就是查询的时候了：</p><p>在二维前缀和问题中，所求问题多半是一段二维区间内的元素和。循序渐进，我们从查询单个元素开始说起：</p><p>（下图中每个方格表示一个元素，实心格子表示待求元素）</p><p><img src="/2024/07/30/Partial-Sum/p0.png" alt="&quot;问题1&quot;"></p><p>其实也很简单，我们只需要把求前缀和的过程反过来就行了：用当前元素前缀和减去那个“L”型元素和即可。</p><p>延伸到一段元素，与单个元素的思路一模一样——用右下角元素的前缀和，减去包裹着整个区间的“L”型即可。</p><p><img src="/2024/07/30/Partial-Sum/p1.png" alt="&quot;问题2&quot;"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>不管是求前缀还是计算区间，重点就是求L型。既然我们已知当前点左侧上侧的全部前缀和，为什么不把这个复杂图形切割成我们已知的图形去做呢？</p><p>很简单，把它分成如图所示的两个前缀和，再减去它们重叠的那部分即可。</p><p><img src="/2024/07/30/Partial-Sum/s0.png" alt="&quot;解决&quot;"></p><p>已经有了思路，下面就直接上公式了:</p><p>求前缀和：<br>$$<br>s_{i,j}&#x3D;s_{i,j-1}+s_{i-1,j}-s_{i-1,j-1}<br>$$</p><p>求[x1][y1]到[x2][y2]的元素之和:<br>$$<br>s_{x2,y2}-s_{x2,y1-1}-s_{x1-1,y2}+s_{x1-1,y1-1}<br>$$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span><span class="hljs-number">+3</span>;<br><br><span class="hljs-type">int</span> n,m,q;<br><span class="hljs-type">int</span> a[N][N],s[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>            s[i][j]=s[i][j<span class="hljs-number">-1</span>]+s[i<span class="hljs-number">-1</span>][j]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> x1,y1,x2,y2;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x2][y1<span class="hljs-number">-1</span>]-s[x1<span class="hljs-number">-1</span>][y2]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1><p><em>写这个真的好繁琐啊，一想到还有差分就啊啊啊啊啊(艹皿艹 )</em></p>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>前缀和与差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-High_Precision(Mul and Div)[SIM]高精度乘除法（基础版）</title>
    <link href="/2024/07/29/High-Precision-MulDiv-Simple/"/>
    <url>/2024/07/29/High-Precision-MulDiv-Simple/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>鉴于此篇博客用于学习or巩固基础部分，故而这里只记录大数与<code>int</code>类型的小数的乘除计算，大数乘大数将会在<a href="https://githarlem.github.io/High-Precison-MulDiv-Complex">“[编程笔记]-High_Precision(Mul and Div)[COM]高精度乘除法（提高版）”</a>教学。</p><p>emmm就这样吧(。·ω·。)</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>其实就跟<strong>列竖式</strong>差不多，把大数列在下面、小数列在上面，直接乘。</p><p><em>别忘了去前导0~</em></p><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>就是用机器去模拟手写嘛。鉴于除法相较于其他三种计算有些复杂，这里给出详细步骤：</p><ol><li>准备好记录结果与记录余数的变量。</li><li>从最高位开始往最低位遍历大数。</li><li>将余数乘十并加上大数的这一位，作为新的被除数。</li><li>记录新的被除数除以小数的商与新余数。</li><li>去掉前导零。</li></ol><p><em>tips: 如果你用的是<code>vector</code>储存，请在第5步前反转队列。（详见代码）</em></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())t+=a[i]*b;<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)c.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;vector&lt;<span class="hljs-type">int</span>&gt;,<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">div</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">int</span> &amp;b)&#123;<span class="hljs-comment">//同时返回结果和余数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        t=t*<span class="hljs-number">10</span>+a[i];<br>        c.<span class="hljs-built_in">push_back</span>(t/b);<span class="hljs-comment">//注意，这里是从最高位开始往最低位储存，所以最后要先反转过来。</span><br>        t%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(c.<span class="hljs-built_in">begin</span>(),c.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//记得#include&lt;algorithm&gt;</span><br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)c.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> &#123;c,t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-High_Precision(Add and Sub)高精度加减法</title>
    <link href="/2024/07/28/High-Precision-AddSub/"/>
    <url>/2024/07/28/High-Precision-AddSub/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客并不打算多细致地讲解高精度，但是！但是！我会给出代码模板，并且在注释中讲解大多数内容。</p><p>就这样吧。（￣︶￣）</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>emmm<strong>小学数学</strong>会吧？<del>不会您先别看了</del> 就用小学数学的思路做就完事了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这里使用vector储存大数，因为它自带size函数，当然直接用数组也没有问题。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||i&lt;b.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())t+=b[i];<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t)c.<span class="hljs-built_in">push_back</span>(t);<span class="hljs-comment">//最后可能还剩一个进位，不要忘了加回去。</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>update 2024&#x2F;7&#x2F;29: 一种更简洁的写法</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||i&lt;b.<span class="hljs-built_in">size</span>()||t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>())t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())t+=b[i];<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//同上</span><br><span class="hljs-comment">//此函数用于判断两个大数大小，下方的减法函数只支持大减小。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>()&gt;b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])<span class="hljs-keyword">return</span> a[i]&gt;b[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//此函数用于大减小，搭配上方函数使用即可。</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-built_in">size</span>())t-=b[i];<br>        c.<span class="hljs-built_in">push_back</span>((t<span class="hljs-number">+10</span>)%<span class="hljs-number">10</span>);<span class="hljs-comment">//此处浓缩了两种可能：t&lt;0，返回t+10；t≥0，返回t。</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>)t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)c.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//删除前置0。当只剩一位时不删（不然0就没了）。</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Binary_Search二分查找</title>
    <link href="/2024/07/28/Binary-Search/"/>
    <url>/2024/07/28/Binary-Search/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二分也算是比较普遍且常用的一个算法了，并且在前期还是个小难点，其相对复杂的类型以及边界问题通常让<em>蒟蒻</em>们很是头疼。</p><p>这一篇博客主要讲解<strong>二分查找</strong>的原理、模板等（不是<strong>二分答案</strong>），并不着重深入讲解其各种变式。</p><p>就这样吧(～￣▽￣)～</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>二分查找就是把一段元素分成两半，用中间值进行对比，判断查找元素在其左侧或右侧，并在那一半进行查找，以到达O(logn)的复杂度。</p><p>因此，理论上来说，所有<strong>单调性</strong>问题都可以用二分解决。当然，<strong>并非只有单调性问题才可以用二分解决</strong>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>二分的实现其实并不难，搞清楚原理后，基本上就没什么问题了。</p><p>这里还是大概贴下思路：</p><ol><li>确定搜索范围。</li><li>获取中间值。<strong>！注意，不同二分方式在这一步的具体实现会有所不同，详见下方！</strong></li><li>判断答案在左侧还是右侧。</li><li>在答案所在一侧重新二分，循环直到范围缩为1。</li><li>判断获得元素是否为所求，若否，则搜索范围中无需要元素。</li></ol><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p><em>整数二分有<strong>两种</strong>形式，我个人将其命名为<strong>左倾二分</strong>以及<strong>右倾二分</strong>（非！官！方！命！名！）</em></p><h3 id="左倾二分"><a href="#左倾二分" class="headerlink" title="左倾二分"></a>左倾二分</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>所谓_左倾_，就是说搜索到的答案<strong>倾向于向左侧靠近</strong>。举例地说，当一段元素中有连续的一段相同元素时，搜索此元素，得到的将会是这一段中最左侧的坐标。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>在计算中间坐标时，<strong>向下取整</strong>。原因会在第二点给出。</li><li>若中间值<strong>大于或等于</strong>答案，则将右边界重设为中间坐标。<strong>因此，中间坐标需向下取整，否则会陷入死循环</strong>。</li><li>否则，将左边界重设为中间坐标**+1**，原因是中间坐标已经确定不是答案，因此不在搜索范围内。</li></ul><h4 id="左倾原因"><a href="#左倾原因" class="headerlink" title="左倾原因"></a>左倾原因</h4><p>若当前搜索范围内值都一致，则都满足<strong>大于或等于</strong>答案，那么会一直重设右边界。同时，中间坐标向下取整，故而范围会一直向左缩小，直到缩小至一个元素，那么就是最左侧的元素了。</p><h3 id="右倾二分"><a href="#右倾二分" class="headerlink" title="右倾二分"></a>右倾二分</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>_右倾_定义可借鉴_左倾_，就是说搜索到的答案<strong>倾向于向右侧靠近</strong>，这里就不做具体阐释。</p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>在计算中间坐标时，<strong>向上取整</strong>。原因会在第三点给出。</li><li>若中间值<strong>大于</strong>答案，则将右边界重设为中间坐标**-1**，原因是中间坐标已经确定不是答案，因此不在搜索范围内。</li><li>否则，将左边界重设为中间坐标。<strong>因此，中间坐标需向上取整，否则会陷入死循环</strong>。</li></ul><h4 id="右倾原因"><a href="#右倾原因" class="headerlink" title="右倾原因"></a>右倾原因</h4><p>若当前搜索范围内值都一致，则都满足<strong>小于或等于</strong>答案，那么会一直重设左边界。同时，中间坐标向上取整，故而范围会一直向右缩小，直到缩小至一个元素，那么就是最右侧的元素了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><em>代码中check函数不固定，视需求而定</em></p><h4 id="左倾二分-1"><a href="#左倾二分-1" class="headerlink" title="左倾二分"></a>左倾二分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(m))r=m;<br>    <span class="hljs-keyword">else</span> l=m<span class="hljs-number">+1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="右倾二分-1"><a href="#右倾二分-1" class="headerlink" title="右倾二分"></a>右倾二分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-type">int</span> m=l+r<span class="hljs-number">+1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(m))r=m<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> l=m;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>浮点数二分相对于整数二分来说简单了很多，但需要注意的是，通常情况下是不能真正搜索到答案的，因此，当当前值与答案之间的差距足够小时，<strong>我们就视之为答案即可</strong>。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和整数二分差不多，取中间值时不存在取整问题，边界开闭随个人喜好。</p><p><strong>循环条件要写成边界之差大于一个较小值！（通常为1e-6以下，具体要求随题目而定）</strong></p><p><em>tips: 若题目有要求，则差值至少比保留小数位数多两位。</em></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> l=<span class="hljs-number">0</span>,r=x;<br><span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-6</span>)&#123;<br><span class="hljs-type">double</span> m=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(m))r=m;<br><span class="hljs-keyword">else</span> l=m;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>二分</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Merge_Sort归并排序</title>
    <link href="/2024/07/27/Merge-Sort/"/>
    <url>/2024/07/27/Merge-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>利用<strong>分治思想</strong>，把数组对半分成两份，各自排好序，再将两个排好序的数组合并成一个数组即可。</p><p>（或许有点废话？Σ(っ °Д °;)っ）</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>这里着重讲以下合并数组的过程：</p><ol><li><p>建立两个指针，指向两边各排好序的数组的首个元素。</p></li><li><p>对指针指向的元素进行对比，更小的（从小到大排序）插入临时数组，直到其中一个指针走到结尾。</p></li><li><p>把两个数组中剩下的元素插入临时数组（其实只会有一个有余，这里不做解释）</p></li><li><p>用临时数组替换原数组中对应元素段。</p></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N],t[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ms</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">ms</span>(l,m);<span class="hljs-built_in">ms</span>(m<span class="hljs-number">+1</span>,r);<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=m<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j])t[k++]=a[i++];<br><span class="hljs-keyword">else</span> t[k++]=a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=m)t[k++]=a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)t[k++]=a[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)a[i]=t[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">ms</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[编程笔记]-Quick_Sort快速排序</title>
    <link href="/2024/07/26/Quick-Sort/"/>
    <url>/2024/07/26/Quick-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h2><p>利用<strong>分治思想</strong>，新建两个数组，分别储存原数组中小于 X 或大于 X 的元素，并分别对其进行快速排序，最后重组原数组即可。（X可为任意值，推荐使用中值）</p><h2 id="进化版"><a href="#进化版" class="headerlink" title="进化版"></a>进化版</h2><p>利用<strong>分治思想</strong>以及部分<strong>双指针思想</strong>，左右各两个指针，记为 i, j。左指针一直向右，直到数组中第 i 个元素大于 x；右指针一直向左，直到数组中第 j 个元素小于x；接着左右指针<strong>对应元素</strong>互换，重复执行直到左右指针相遇。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>平均O(nlogn)，最大O(n<sup>2</sup>)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> x=q[l+r&gt;&gt;<span class="hljs-number">1</span>],i=l<span class="hljs-number">-1</span>,j=r<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(q[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(q[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j)<span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q,l,j);<br>    <span class="hljs-built_in">quick_sort</span>(q,j<span class="hljs-number">+1</span>,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>编程笔记</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>编程</tag>
      
      <tag>c++</tag>
      
      <tag>笔记</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
