<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[算法笔记]-High_Precision(Mul and Div)[SIM]高精度乘除法（基础版）</title>
    <link href="/2024/07/29/High-Precision-MulDiv-Simple/"/>
    <url>/2024/07/29/High-Precision-MulDiv-Simple/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>鉴于此篇博客用于学习or巩固基础部分，故而这里只记录大数与<code>int</code>类型的小数的乘除计算，大数乘大数将会在<a href="https://githarlem.github.io/High-Precison-MulDiv-Complex">“[算法笔记]-High_Precision(Mul and Div)[COM]高精度乘除法（提高版）”</a>教学。</p><p>emmm就这样吧(。·ω·。)</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>其实就跟<strong>列竖式</strong>差不多，把大数列在下面、小数列在上面，直接乘。</p><p><em>别忘了去前导0~</em></p><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>就是用机器去模拟手写嘛。鉴于除法相较于其他三种计算有些复杂，这里给出详细步骤：</p><ol><li>准备好记录结果与记录余数的变量。</li><li>从最高位开始往最低位遍历大数。</li><li>将余数乘十并加上大数的这一位，作为新的被除数。</li><li>记录新的被除数除以小数的商与新余数。</li><li>去掉前导零。</li></ol><p><em>tips: 如果你用的是<code>vector</code>储存，请在第5步前反转队列。（详见代码）</em></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; mul(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a,<span class="hljs-keyword">int</span> b)&#123;<br>    <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; c;<span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-keyword">size</span>()||t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-keyword">size</span>())t+=a[i]*b;<br>        c.push_back(t%10);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-keyword">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.back()==<span class="hljs-number">0</span>)c.pop_back();<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;vector&lt;<span class="hljs-type">int</span>&gt;,<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">div</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">int</span> &amp;b)&#123;<span class="hljs-comment">//同时返回结果和余数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; c;<span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        t=t*<span class="hljs-number">10</span>+a[i];<br>        c.<span class="hljs-built_in">push_back</span>(t/b);<span class="hljs-comment">//注意，这里是从最高位开始往最低位储存，所以最后要先反转过来。</span><br>        t%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(c.<span class="hljs-built_in">begin</span>(),c.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//记得#include&lt;algorithm&gt;</span><br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)c.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> &#123;c,t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>高精度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
      <tag>基础</tag>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[算法笔记]-High_Precision(Add and Sub)高精度加减法</title>
    <link href="/2024/07/28/High-Precision-AddSub/"/>
    <url>/2024/07/28/High-Precision-AddSub/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇博客并不打算多细致地讲解高精度，但是！但是！我会给出代码模板，并且在注释中讲解大多数内容。</p><p>就这样吧。（￣︶￣）</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>emmm<strong>小学数学</strong>会吧？<del>不会您先别看了</del> 就用小学数学的思路做就完事了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">//这里使用vector储存大数，因为它自带size函数，当然直接用数组也没有问题。</span><br><span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; add(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;a,<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;b)&#123;<br>    <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; c;<br>    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-keyword">size</span>()||i&lt;b.<span class="hljs-keyword">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-keyword">size</span>())t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-keyword">size</span>())t+=b[i];<br>        c.push_back(t%10);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t)c.push_back(t);<span class="hljs-comment">//最后可能还剩一个进位，不要忘了加回去。</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>update 2024&#x2F;7&#x2F;29: 一种更简洁的写法</em></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; add(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;a,<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;b)&#123;<br>    <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; c;<br>    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-keyword">size</span>()||i&lt;b.<span class="hljs-keyword">size</span>()||t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-keyword">size</span>())t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-keyword">size</span>())t+=b[i];<br>        c.push_back(t%10);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">//同上</span><br><span class="hljs-comment">//此函数用于判断两个大数大小，下方的减法函数只支持大减小。</span><br>bool cmp(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;a,<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;b)&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-keyword">size</span>()!=b.<span class="hljs-keyword">size</span>())<span class="hljs-keyword">return</span> a.<span class="hljs-keyword">size</span>()&gt;b.<span class="hljs-keyword">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=a.<span class="hljs-keyword">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])<span class="hljs-keyword">return</span> a[i]&gt;b[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> true;<br>&#125;<br><br><span class="hljs-comment">//此函数用于大减小，搭配上方函数使用即可。</span><br><span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sub(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;a,<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;b)&#123;<br>    <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; c;<br>    <span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-keyword">size</span>();i++)&#123;<br>        t+=a[i];<br>        <span class="hljs-keyword">if</span>(i&lt;b.<span class="hljs-keyword">size</span>())t-=b[i];<br>        c.push_back((t+<span class="hljs-number">10</span>)%10);<span class="hljs-comment">//此处浓缩了两种可能：t&lt;0，返回t+10；t≥0，返回t。</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>)t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-keyword">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;c.back()==<span class="hljs-number">0</span>)c.pop_back();<span class="hljs-comment">//删除前置0。当只剩一位时不删（不然0就没了）。</span><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>高精度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
      <tag>基础</tag>
      
      <tag>高精度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[算法笔记]-Binary_Search二分查找</title>
    <link href="/2024/07/28/Binary-Search/"/>
    <url>/2024/07/28/Binary-Search/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二分也算是比较普遍且常用的一个算法了，并且在前期还是个小难点，其相对复杂的类型以及边界问题通常让<em>蒟蒻</em>们很是头疼。</p><p>这一篇博客主要讲解<strong>二分查找</strong>的原理、模板等（不是<strong>二分答案</strong>），并不着重深入讲解其各种变式。</p><p>就这样吧(～￣▽￣)～</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>二分查找就是把一段元素分成两半，用中间值进行对比，判断查找元素在其左侧或右侧，并在那一半进行查找，以到达O(logn)的复杂度。</p><p>因此，理论上来说，所有<strong>单调性</strong>问题都可以用二分解决。当然，<strong>并非只有单调性问题才可以用二分解决</strong>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>二分的实现其实并不难，搞清楚原理后，基本上就没什么问题了。</p><p>这里还是大概贴下思路：</p><ol><li>确定搜索范围。</li><li>获取中间值。<strong>！注意，不同二分方式在这一步的具体实现会有所不同，详见下方！</strong></li><li>判断答案在左侧还是右侧。</li><li>在答案所在一侧重新二分，循环直到范围缩为1。</li><li>判断获得元素是否为所求，若否，则搜索范围中无需要元素。</li></ol><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p><em>整数二分有<strong>两种</strong>形式，我个人将其命名为<strong>左倾二分</strong>以及<strong>右倾二分</strong>（非！官！方！命！名！）</em></p><h3 id="左倾二分"><a href="#左倾二分" class="headerlink" title="左倾二分"></a>左倾二分</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>所谓_左倾_，就是说搜索到的答案<strong>倾向于向左侧靠近</strong>。举例地说，当一段元素中有连续的一段相同元素时，搜索此元素，得到的将会是这一段中最左侧的坐标。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>在计算中间坐标时，<strong>向下取整</strong>。原因会在第二点给出。</li><li>若中间值<strong>大于或等于</strong>答案，则将右边界重设为中间坐标。<strong>因此，中间坐标需向下取整，否则会陷入死循环</strong>。</li><li>否则，将左边界重设为中间坐标**+1**，原因是中间坐标已经确定不是答案，因此不在搜索范围内。</li></ul><h4 id="左倾原因"><a href="#左倾原因" class="headerlink" title="左倾原因"></a>左倾原因</h4><p>若当前搜索范围内值都一致，则都满足<strong>大于或等于</strong>答案，那么会一直重设右边界。同时，中间坐标向下取整，故而范围会一直向左缩小，直到缩小至一个元素，那么就是最左侧的元素了。</p><h3 id="右倾二分"><a href="#右倾二分" class="headerlink" title="右倾二分"></a>右倾二分</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>_右倾_定义可借鉴_左倾_，就是说搜索到的答案<strong>倾向于向右侧靠近</strong>，这里就不做具体阐释。</p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>在计算中间坐标时，<strong>向上取整</strong>。原因会在第三点给出。</li><li>若中间值<strong>大于</strong>答案，则将右边界重设为中间坐标**-1**，原因是中间坐标已经确定不是答案，因此不在搜索范围内。</li><li>否则，将左边界重设为中间坐标。<strong>因此，中间坐标需向上取整，否则会陷入死循环</strong>。</li></ul><h4 id="右倾原因"><a href="#右倾原因" class="headerlink" title="右倾原因"></a>右倾原因</h4><p>若当前搜索范围内值都一致，则都满足<strong>小于或等于</strong>答案，那么会一直重设左边界。同时，中间坐标向上取整，故而范围会一直向右缩小，直到缩小至一个元素，那么就是最右侧的元素了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><em>代码中check函数不固定，视需求而定</em></p><h4 id="左倾二分-1"><a href="#左倾二分-1" class="headerlink" title="左倾二分"></a>左倾二分</h4><pre><code class="hljs">int l=0,r=n-1;while(l&lt;r)&#123;    int m=l+r&gt;&gt;1;    if(check(m))r=m;    else l=m+1;&#125;</code></pre><h4 id="右倾二分-1"><a href="#右倾二分-1" class="headerlink" title="右倾二分"></a>右倾二分</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int <span class="hljs-attribute">l</span>=0,r=n-1;<br><span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    int <span class="hljs-attribute">m</span>=l+r+1&gt;&gt;1;<br>    <span class="hljs-keyword">if</span>(check(m))<span class="hljs-attribute">r</span>=m-1;<br>    <span class="hljs-keyword">else</span> <span class="hljs-attribute">l</span>=m;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>浮点数二分相对于整数二分来说简单了很多，但需要注意的是，通常情况下是不能真正搜索到答案的，因此，当当前值与答案之间的差距足够小时，<strong>我们就视之为答案即可</strong>。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和整数二分差不多，取中间值时不存在取整问题，边界开闭随个人喜好。</p><p><strong>循环条件要写成边界之差大于一个较小值！（通常为1e-6以下，具体要求随题目而定）</strong></p><p><em>tips: 若题目有要求，则差值至少比保留小数位数多两位。</em></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">double <span class="hljs-attribute">l</span>=0,r=x;<br><span class="hljs-keyword">while</span>(r-l&gt;1e-6)&#123;<br>double m=(l+r)/2;<br><span class="hljs-keyword">if</span>(check(m))<span class="hljs-attribute">r</span>=m;<br><span class="hljs-keyword">else</span> <span class="hljs-attribute">l</span>=m;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>二分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
      <tag>基础</tag>
      
      <tag>二分</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[算法笔记]-Merge_Sort归并排序</title>
    <link href="/2024/07/27/Merge-Sort/"/>
    <url>/2024/07/27/Merge-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>利用<strong>分治思想</strong>，把数组对半分成两份，各自排好序，再将两个排好序的数组合并成一个数组即可。</p><p>（或许有点废话？Σ(っ °Д °;)っ）</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>这里着重讲以下合并数组的过程：</p><ol><li><p>建立两个指针，指向两边各排好序的数组的首个元素。</p></li><li><p>对指针指向的元素进行对比，更小的（从小到大排序）插入临时数组，直到其中一个指针走到结尾。</p></li><li><p>把两个数组中剩下的元素插入临时数组（其实只会有一个有余，这里不做解释）</p></li><li><p>用临时数组替换原数组中对应元素段。</p></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N],t[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ms</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> m=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">ms</span>(l,m);<span class="hljs-built_in">ms</span>(m<span class="hljs-number">+1</span>,r);<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=m<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j])t[k++]=a[i++];<br><span class="hljs-keyword">else</span> t[k++]=a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=m)t[k++]=a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)t[k++]=a[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)a[i]=t[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">ms</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
      <tag>基础</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[算法笔记]-Quick_Sort快速排序</title>
    <link href="/2024/07/26/Quick-Sort/"/>
    <url>/2024/07/26/Quick-Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h2><p>利用<strong>分治思想</strong>，新建两个数组，分别储存原数组中小于 X 或大于 X 的元素，并分别对其进行快速排序，最后重组原数组即可。（X可为任意值，推荐使用中值）</p><h2 id="进化版"><a href="#进化版" class="headerlink" title="进化版"></a>进化版</h2><p>利用<strong>分治思想</strong>以及部分<strong>双指针思想</strong>，左右各两个指针，记为 i, j。左指针一直向右，直到数组中第 i 个元素大于 x；右指针一直向左，直到数组中第 j 个元素小于x；接着左右指针<strong>对应元素</strong>互换，重复执行直到左右指针相遇。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>平均O(nlogn)，最大O(n<sup>2</sup>)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br><br>const <span class="hljs-keyword">int</span> N=1e5+<span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> <span class="hljs-string">q[N]</span>;<br><br>void quick_sort(<span class="hljs-keyword">int</span> <span class="hljs-string">q[]</span>,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>=<span class="hljs-string">q[l+r&gt;&gt;1]</span>,i=l-<span class="hljs-number">1</span>,j=r+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(<span class="hljs-string">q[i]</span>&lt;<span class="hljs-keyword">x</span>);<br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(<span class="hljs-string">q[j]</span>&gt;<span class="hljs-keyword">x</span>);<br>        <span class="hljs-keyword">if</span>(i&lt;j)swap(<span class="hljs-string">q[i]</span>,<span class="hljs-string">q[j]</span>);<br>    &#125;<br>    quick_sort(<span class="hljs-keyword">q</span>,l,j);<br>    quick_sort(<span class="hljs-keyword">q</span>,j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><span class="hljs-keyword">int</span> main()&#123;<br>    scanf(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span>&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)scanf(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span>&quot;</span>,&amp;<span class="hljs-string">q[i]</span>);<br>    quick_sort(<span class="hljs-keyword">q</span>,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;<span class="hljs-variable">%d</span> &quot;</span>,<span class="hljs-string">q[i]</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="完结撒花o-￣︶￣-o"><a href="#完结撒花o-￣︶￣-o" class="headerlink" title="完结撒花o(￣︶￣)o"></a>完结撒花o(<em>￣︶￣</em>)o</h1>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>算法</tag>
      
      <tag>笔记</tag>
      
      <tag>基础</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
